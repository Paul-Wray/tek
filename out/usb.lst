                                      1 ;--------------------------------------------------------
                                      2 ; File Created by SDCC : free open source ANSI-C Compiler
                                      3 ; Version 3.9.0 #11195 (MINGW32)
                                      4 ;--------------------------------------------------------
                                      5 	.module usb
                                      6 	.optsdcc -mmcs51 --model-small
                                      7 	
                                      8 ;--------------------------------------------------------
                                      9 ; Public variables in this module
                                     10 ;--------------------------------------------------------
                                     11 	.globl _USB_Wr_FIFO_PARM_2
                                     12 	.globl _USB_Rd_FIFO_PARM_2
                                     13 	.globl _SERIALNUMBER_DESCRIPTOR
                                     14 	.globl _PRODUCT_DESCRIPTOR
                                     15 	.globl _MANUFACTURER_DESCRIPTOR
                                     16 	.globl _LANGUAGEID_DESCRIPTOR
                                     17 	.globl _KB_INTERRUPT_IN_ENDPOINT_DESCRIPTOR
                                     18 	.globl _KB_HID_DESCRIPTOR
                                     19 	.globl _KB_INTERFACE_DESCRIPTOR
                                     20 	.globl _CONGFIGURATION_DESCRIPTOR
                                     21 	.globl _DEVICE_DESCRIPTOR
                                     22 	.globl _KB_HID_REPORT
                                     23 	.globl _USB_Int
                                     24 	.globl _USB_Set_TxStatus
                                     25 	.globl _USB_CtrlWr
                                     26 	.globl _USB_Class_Request
                                     27 	.globl _USB_Stardard_Request
                                     28 	.globl _USB_CtrlRd
                                     29 	.globl _USB_Get_Interface
                                     30 	.globl _USB_Set_Interface
                                     31 	.globl _USB_Set_Configuration
                                     32 	.globl _USB_Get_Descriptor
                                     33 	.globl _USB_Set_Feature
                                     34 	.globl _USB_Clear_Feature
                                     35 	.globl _USB_Get_Status
                                     36 	.globl _USB_Ep0_FIFO
                                     37 	.globl _USB_Wr_FIFO
                                     38 	.globl _USB_Rd_FIFO
                                     39 	.globl _Initial_USB
                                     40 	.globl _initKeyboard
                                     41 	.globl _KB_LED_Off
                                     42 	.globl _KB_LED_Status
                                     43 	.globl _Delay_Xms
                                     44 	.globl _Reboot_Mcu
                                     45 	.globl _INT2
                                     46 	.globl _INT3
                                     47 	.globl _RXD
                                     48 	.globl _TXD
                                     49 	.globl _INT0
                                     50 	.globl _INT1
                                     51 	.globl _T0
                                     52 	.globl _T1
                                     53 	.globl _WR
                                     54 	.globl _RD
                                     55 	.globl _I2C_SCL
                                     56 	.globl _I2C_SDA
                                     57 	.globl _SPI_SS
                                     58 	.globl _SPI_MOSI
                                     59 	.globl _SPI_MISO
                                     60 	.globl _SPI_CLK
                                     61 	.globl _T2
                                     62 	.globl _T2EX
                                     63 	.globl _P40
                                     64 	.globl _P41
                                     65 	.globl _P42
                                     66 	.globl _P43
                                     67 	.globl _P30
                                     68 	.globl _P31
                                     69 	.globl _P32
                                     70 	.globl _P33
                                     71 	.globl _P34
                                     72 	.globl _P35
                                     73 	.globl _P36
                                     74 	.globl _P37
                                     75 	.globl _P20
                                     76 	.globl _P21
                                     77 	.globl _P22
                                     78 	.globl _P23
                                     79 	.globl _P24
                                     80 	.globl _P25
                                     81 	.globl _P26
                                     82 	.globl _P27
                                     83 	.globl _P10
                                     84 	.globl _P11
                                     85 	.globl _P12
                                     86 	.globl _P13
                                     87 	.globl _P14
                                     88 	.globl _P15
                                     89 	.globl _P16
                                     90 	.globl _P17
                                     91 	.globl _P00
                                     92 	.globl _P01
                                     93 	.globl _P02
                                     94 	.globl _P03
                                     95 	.globl _P04
                                     96 	.globl _P05
                                     97 	.globl _P06
                                     98 	.globl _P07
                                     99 	.globl _CR0
                                    100 	.globl _CR1
                                    101 	.globl _AA
                                    102 	.globl _SI
                                    103 	.globl _STO
                                    104 	.globl _STA
                                    105 	.globl _ENSI
                                    106 	.globl _CR2
                                    107 	.globl _IT2
                                    108 	.globl _IE2
                                    109 	.globl _EX2
                                    110 	.globl _IL2
                                    111 	.globl _IT3
                                    112 	.globl _IE3
                                    113 	.globl _EX3
                                    114 	.globl _IL3
                                    115 	.globl _CP_RL2
                                    116 	.globl _C_T2
                                    117 	.globl _TR2
                                    118 	.globl _EXEN2
                                    119 	.globl _TCLK
                                    120 	.globl _RCLK
                                    121 	.globl _EXF2
                                    122 	.globl _TF2
                                    123 	.globl _IT0
                                    124 	.globl _IE0
                                    125 	.globl _IT1
                                    126 	.globl _IE1
                                    127 	.globl _TR0
                                    128 	.globl _TF0
                                    129 	.globl _TR1
                                    130 	.globl _TF1
                                    131 	.globl _FE
                                    132 	.globl _RI
                                    133 	.globl _TI
                                    134 	.globl _RB8
                                    135 	.globl _TB8
                                    136 	.globl _REN
                                    137 	.globl _SM2
                                    138 	.globl _SM1
                                    139 	.globl _SM0
                                    140 	.globl _PX0
                                    141 	.globl _PT0
                                    142 	.globl _PX1
                                    143 	.globl _PT1
                                    144 	.globl _PS
                                    145 	.globl _PT2
                                    146 	.globl _PX2
                                    147 	.globl _PX3
                                    148 	.globl _EX0
                                    149 	.globl _ET0
                                    150 	.globl _EX1
                                    151 	.globl _ET1
                                    152 	.globl _ES
                                    153 	.globl _ET2
                                    154 	.globl _EA
                                    155 	.globl _P
                                    156 	.globl _OV
                                    157 	.globl _RS0
                                    158 	.globl _RS1
                                    159 	.globl _F0
                                    160 	.globl _AC
                                    161 	.globl _CY
                                    162 	.globl _SCMD
                                    163 	.globl _IFADRL
                                    164 	.globl _IFADRH
                                    165 	.globl _IFD
                                    166 	.globl _ISPTME
                                    167 	.globl _ISPCR
                                    168 	.globl _WDTCR
                                    169 	.globl _AUXR2
                                    170 	.globl _AUXR
                                    171 	.globl _CKCON2
                                    172 	.globl _CKCON
                                    173 	.globl _PCON
                                    174 	.globl _SISTA
                                    175 	.globl _SIDAT
                                    176 	.globl _SIADR
                                    177 	.globl _SICON
                                    178 	.globl _SPSTAT
                                    179 	.globl _SPDAT
                                    180 	.globl _SPCTL
                                    181 	.globl _KBMASK
                                    182 	.globl _KBPATN
                                    183 	.globl _KBCON
                                    184 	.globl _SADEN
                                    185 	.globl _SADDR
                                    186 	.globl _SBUF
                                    187 	.globl _SCON
                                    188 	.globl _TH2
                                    189 	.globl _TL2
                                    190 	.globl _TH1
                                    191 	.globl _TL1
                                    192 	.globl _TH0
                                    193 	.globl _TL0
                                    194 	.globl _RCAP2H
                                    195 	.globl _RCAP2L
                                    196 	.globl _T2MOD
                                    197 	.globl _T2CON
                                    198 	.globl _TMOD
                                    199 	.globl _TCON
                                    200 	.globl _P4M1
                                    201 	.globl _P4M0
                                    202 	.globl _P3M1
                                    203 	.globl _P3M0
                                    204 	.globl _P2M1
                                    205 	.globl _P2M0
                                    206 	.globl _P1M1
                                    207 	.globl _P1M0
                                    208 	.globl _P0M1
                                    209 	.globl _P0M0
                                    210 	.globl _P4
                                    211 	.globl _P3
                                    212 	.globl _P2
                                    213 	.globl _P1
                                    214 	.globl _P0
                                    215 	.globl _IP
                                    216 	.globl _XICON
                                    217 	.globl _AUXIP
                                    218 	.globl _AUXIE
                                    219 	.globl _IE
                                    220 	.globl _PSW
                                    221 	.globl _DPH
                                    222 	.globl _DPL
                                    223 	.globl _SP
                                    224 	.globl _B
                                    225 	.globl _ACC
                                    226 	.globl _Ep0
                                    227 	.globl _Protocol
                                    228 	.globl _IdleRate
                                    229 	.globl _TxBusy
                                    230 ;--------------------------------------------------------
                                    231 ; special function registers
                                    232 ;--------------------------------------------------------
                                    233 	.area RSEG    (ABS,DATA)
      000000                        234 	.org 0x0000
                           0000E0   235 _ACC	=	0x00e0
                           0000F0   236 _B	=	0x00f0
                           000081   237 _SP	=	0x0081
                           000082   238 _DPL	=	0x0082
                           000083   239 _DPH	=	0x0083
                           0000D0   240 _PSW	=	0x00d0
                           0000A8   241 _IE	=	0x00a8
                           0000AD   242 _AUXIE	=	0x00ad
                           0000AE   243 _AUXIP	=	0x00ae
                           0000C0   244 _XICON	=	0x00c0
                           0000B8   245 _IP	=	0x00b8
                           000080   246 _P0	=	0x0080
                           000090   247 _P1	=	0x0090
                           0000A0   248 _P2	=	0x00a0
                           0000B0   249 _P3	=	0x00b0
                           0000E8   250 _P4	=	0x00e8
                           000093   251 _P0M0	=	0x0093
                           000094   252 _P0M1	=	0x0094
                           000091   253 _P1M0	=	0x0091
                           000092   254 _P1M1	=	0x0092
                           000095   255 _P2M0	=	0x0095
                           000096   256 _P2M1	=	0x0096
                           0000B1   257 _P3M0	=	0x00b1
                           0000B2   258 _P3M1	=	0x00b2
                           0000B3   259 _P4M0	=	0x00b3
                           0000B4   260 _P4M1	=	0x00b4
                           000088   261 _TCON	=	0x0088
                           000089   262 _TMOD	=	0x0089
                           0000C8   263 _T2CON	=	0x00c8
                           0000C9   264 _T2MOD	=	0x00c9
                           0000CA   265 _RCAP2L	=	0x00ca
                           0000CB   266 _RCAP2H	=	0x00cb
                           00008A   267 _TL0	=	0x008a
                           00008C   268 _TH0	=	0x008c
                           00008B   269 _TL1	=	0x008b
                           00008D   270 _TH1	=	0x008d
                           0000CC   271 _TL2	=	0x00cc
                           0000CD   272 _TH2	=	0x00cd
                           000098   273 _SCON	=	0x0098
                           000099   274 _SBUF	=	0x0099
                           0000A9   275 _SADDR	=	0x00a9
                           0000B9   276 _SADEN	=	0x00b9
                           0000D6   277 _KBCON	=	0x00d6
                           0000D5   278 _KBPATN	=	0x00d5
                           0000D7   279 _KBMASK	=	0x00d7
                           000085   280 _SPCTL	=	0x0085
                           000086   281 _SPDAT	=	0x0086
                           000084   282 _SPSTAT	=	0x0084
                           0000F8   283 _SICON	=	0x00f8
                           0000D1   284 _SIADR	=	0x00d1
                           0000D2   285 _SIDAT	=	0x00d2
                           0000D3   286 _SISTA	=	0x00d3
                           000087   287 _PCON	=	0x0087
                           0000C7   288 _CKCON	=	0x00c7
                           0000BF   289 _CKCON2	=	0x00bf
                           00008E   290 _AUXR	=	0x008e
                           0000A6   291 _AUXR2	=	0x00a6
                           0000E1   292 _WDTCR	=	0x00e1
                           0000E7   293 _ISPCR	=	0x00e7
                           0000E5   294 _ISPTME	=	0x00e5
                           0000E2   295 _IFD	=	0x00e2
                           0000E3   296 _IFADRH	=	0x00e3
                           0000E4   297 _IFADRL	=	0x00e4
                           0000E6   298 _SCMD	=	0x00e6
                                    299 ;--------------------------------------------------------
                                    300 ; special function bits
                                    301 ;--------------------------------------------------------
                                    302 	.area RSEG    (ABS,DATA)
      000000                        303 	.org 0x0000
                           0000D7   304 _CY	=	0x00d7
                           0000D6   305 _AC	=	0x00d6
                           0000D5   306 _F0	=	0x00d5
                           0000D4   307 _RS1	=	0x00d4
                           0000D3   308 _RS0	=	0x00d3
                           0000D2   309 _OV	=	0x00d2
                           0000D0   310 _P	=	0x00d0
                           0000AF   311 _EA	=	0x00af
                           0000AD   312 _ET2	=	0x00ad
                           0000AC   313 _ES	=	0x00ac
                           0000AB   314 _ET1	=	0x00ab
                           0000AA   315 _EX1	=	0x00aa
                           0000A9   316 _ET0	=	0x00a9
                           0000A8   317 _EX0	=	0x00a8
                           0000BF   318 _PX3	=	0x00bf
                           0000BE   319 _PX2	=	0x00be
                           0000BD   320 _PT2	=	0x00bd
                           0000BC   321 _PS	=	0x00bc
                           0000BB   322 _PT1	=	0x00bb
                           0000BA   323 _PX1	=	0x00ba
                           0000B9   324 _PT0	=	0x00b9
                           0000B8   325 _PX0	=	0x00b8
                           00009F   326 _SM0	=	0x009f
                           00009E   327 _SM1	=	0x009e
                           00009D   328 _SM2	=	0x009d
                           00009C   329 _REN	=	0x009c
                           00009B   330 _TB8	=	0x009b
                           00009A   331 _RB8	=	0x009a
                           000099   332 _TI	=	0x0099
                           000098   333 _RI	=	0x0098
                           00009F   334 _FE	=	0x009f
                           00008F   335 _TF1	=	0x008f
                           00008E   336 _TR1	=	0x008e
                           00008D   337 _TF0	=	0x008d
                           00008C   338 _TR0	=	0x008c
                           00008B   339 _IE1	=	0x008b
                           00008A   340 _IT1	=	0x008a
                           000089   341 _IE0	=	0x0089
                           000088   342 _IT0	=	0x0088
                           0000CF   343 _TF2	=	0x00cf
                           0000CE   344 _EXF2	=	0x00ce
                           0000CD   345 _RCLK	=	0x00cd
                           0000CC   346 _TCLK	=	0x00cc
                           0000CB   347 _EXEN2	=	0x00cb
                           0000CA   348 _TR2	=	0x00ca
                           0000C9   349 _C_T2	=	0x00c9
                           0000C8   350 _CP_RL2	=	0x00c8
                           0000C7   351 _IL3	=	0x00c7
                           0000C6   352 _EX3	=	0x00c6
                           0000C5   353 _IE3	=	0x00c5
                           0000C4   354 _IT3	=	0x00c4
                           0000C3   355 _IL2	=	0x00c3
                           0000C2   356 _EX2	=	0x00c2
                           0000C1   357 _IE2	=	0x00c1
                           0000C0   358 _IT2	=	0x00c0
                           0000FF   359 _CR2	=	0x00ff
                           0000FE   360 _ENSI	=	0x00fe
                           0000FD   361 _STA	=	0x00fd
                           0000FC   362 _STO	=	0x00fc
                           0000FB   363 _SI	=	0x00fb
                           0000FA   364 _AA	=	0x00fa
                           0000F9   365 _CR1	=	0x00f9
                           0000F8   366 _CR0	=	0x00f8
                           000087   367 _P07	=	0x0087
                           000086   368 _P06	=	0x0086
                           000085   369 _P05	=	0x0085
                           000084   370 _P04	=	0x0084
                           000083   371 _P03	=	0x0083
                           000082   372 _P02	=	0x0082
                           000081   373 _P01	=	0x0081
                           000080   374 _P00	=	0x0080
                           000097   375 _P17	=	0x0097
                           000096   376 _P16	=	0x0096
                           000095   377 _P15	=	0x0095
                           000094   378 _P14	=	0x0094
                           000093   379 _P13	=	0x0093
                           000092   380 _P12	=	0x0092
                           000091   381 _P11	=	0x0091
                           000090   382 _P10	=	0x0090
                           0000A7   383 _P27	=	0x00a7
                           0000A6   384 _P26	=	0x00a6
                           0000A5   385 _P25	=	0x00a5
                           0000A4   386 _P24	=	0x00a4
                           0000A3   387 _P23	=	0x00a3
                           0000A2   388 _P22	=	0x00a2
                           0000A1   389 _P21	=	0x00a1
                           0000A0   390 _P20	=	0x00a0
                           0000B7   391 _P37	=	0x00b7
                           0000B6   392 _P36	=	0x00b6
                           0000B5   393 _P35	=	0x00b5
                           0000B4   394 _P34	=	0x00b4
                           0000B3   395 _P33	=	0x00b3
                           0000B2   396 _P32	=	0x00b2
                           0000B1   397 _P31	=	0x00b1
                           0000B0   398 _P30	=	0x00b0
                           0000EB   399 _P43	=	0x00eb
                           0000EA   400 _P42	=	0x00ea
                           0000E9   401 _P41	=	0x00e9
                           0000E8   402 _P40	=	0x00e8
                           000091   403 _T2EX	=	0x0091
                           000090   404 _T2	=	0x0090
                           0000A7   405 _SPI_CLK	=	0x00a7
                           0000A6   406 _SPI_MISO	=	0x00a6
                           0000A5   407 _SPI_MOSI	=	0x00a5
                           0000A4   408 _SPI_SS	=	0x00a4
                           0000A1   409 _I2C_SDA	=	0x00a1
                           0000A0   410 _I2C_SCL	=	0x00a0
                           0000B7   411 _RD	=	0x00b7
                           0000B6   412 _WR	=	0x00b6
                           0000B5   413 _T1	=	0x00b5
                           0000B4   414 _T0	=	0x00b4
                           0000B3   415 _INT1	=	0x00b3
                           0000B2   416 _INT0	=	0x00b2
                           0000B1   417 _TXD	=	0x00b1
                           0000B0   418 _RXD	=	0x00b0
                           0000B7   419 _INT3	=	0x00b7
                           0000B6   420 _INT2	=	0x00b6
                                    421 ;--------------------------------------------------------
                                    422 ; overlayable register banks
                                    423 ;--------------------------------------------------------
                                    424 	.area REG_BANK_0	(REL,OVR,DATA)
      000000                        425 	.ds 8
                                    426 ;--------------------------------------------------------
                                    427 ; internal ram data
                                    428 ;--------------------------------------------------------
                                    429 	.area DSEG    (DATA)
      000000                        430 _TxBusy::
      000000                        431 	.ds 1
      000001                        432 _IdleRate::
      000001                        433 	.ds 1
      000002                        434 _Protocol::
      000002                        435 	.ds 1
      000003                        436 _Ep0::
      000003                        437 	.ds 19
                                    438 ;--------------------------------------------------------
                                    439 ; overlayable items in internal ram 
                                    440 ;--------------------------------------------------------
                                    441 	.area	OSEG    (OVR,DATA)
      000000                        442 _USB_Rd_FIFO_PARM_2:
      000000                        443 	.ds 1
                                    444 	.area	OSEG    (OVR,DATA)
      000000                        445 _USB_Wr_FIFO_PARM_2:
      000000                        446 	.ds 1
                                    447 	.area	OSEG    (OVR,DATA)
      000000                        448 _USB_Get_Descriptor_WLen_65536_35:
      000000                        449 	.ds 2
                                    450 	.area	OSEG    (OVR,DATA)
                                    451 	.area	OSEG    (OVR,DATA)
                                    452 ;--------------------------------------------------------
                                    453 ; indirectly addressable internal ram data
                                    454 ;--------------------------------------------------------
                                    455 	.area ISEG    (DATA)
                                    456 ;--------------------------------------------------------
                                    457 ; absolute internal ram data
                                    458 ;--------------------------------------------------------
                                    459 	.area IABS    (ABS,DATA)
                                    460 	.area IABS    (ABS,DATA)
                                    461 ;--------------------------------------------------------
                                    462 ; bit data
                                    463 ;--------------------------------------------------------
                                    464 	.area BSEG    (BIT)
                                    465 ;--------------------------------------------------------
                                    466 ; paged external ram data
                                    467 ;--------------------------------------------------------
                                    468 	.area PSEG    (PAG,XDATA)
                                    469 ;--------------------------------------------------------
                                    470 ; external ram data
                                    471 ;--------------------------------------------------------
                                    472 	.area XSEG    (XDATA)
                                    473 ;--------------------------------------------------------
                                    474 ; absolute external ram data
                                    475 ;--------------------------------------------------------
                                    476 	.area XABS    (ABS,XDATA)
                                    477 ;--------------------------------------------------------
                                    478 ; external initialized ram data
                                    479 ;--------------------------------------------------------
                                    480 	.area XISEG   (XDATA)
                                    481 	.area HOME    (CODE)
                                    482 	.area GSINIT0 (CODE)
                                    483 	.area GSINIT1 (CODE)
                                    484 	.area GSINIT2 (CODE)
                                    485 	.area GSINIT3 (CODE)
                                    486 	.area GSINIT4 (CODE)
                                    487 	.area GSINIT5 (CODE)
                                    488 	.area GSINIT  (CODE)
                                    489 	.area GSFINAL (CODE)
                                    490 	.area CSEG    (CODE)
                                    491 ;--------------------------------------------------------
                                    492 ; global & static initialisations
                                    493 ;--------------------------------------------------------
                                    494 	.area HOME    (CODE)
                                    495 	.area GSINIT  (CODE)
                                    496 	.area GSFINAL (CODE)
                                    497 	.area GSINIT  (CODE)
                                    498 ;--------------------------------------------------------
                                    499 ; Home
                                    500 ;--------------------------------------------------------
                                    501 	.area HOME    (CODE)
                                    502 	.area HOME    (CODE)
                                    503 ;--------------------------------------------------------
                                    504 ; code
                                    505 ;--------------------------------------------------------
                                    506 	.area CSEG    (CODE)
                                    507 ;------------------------------------------------------------
                                    508 ;Allocation info for local variables in function 'Initial_USB'
                                    509 ;------------------------------------------------------------
                                    510 ;	usb.c:30: void Initial_USB( void )
                                    511 ;	-----------------------------------------
                                    512 ;	 function Initial_USB
                                    513 ;	-----------------------------------------
      000000                        514 _Initial_USB:
                           000007   515 	ar7 = 0x07
                           000006   516 	ar6 = 0x06
                           000005   517 	ar5 = 0x05
                           000004   518 	ar4 = 0x04
                           000003   519 	ar3 = 0x03
                           000002   520 	ar2 = 0x02
                           000001   521 	ar1 = 0x01
                           000000   522 	ar0 = 0x00
                                    523 ;	usb.c:31: { USB[IEN] = CLR;                              // Disable USB all related interrupts
      000000 90 FF D9         [24]  524 	mov	dptr,#0xffd9
      000003 E4               [12]  525 	clr	a
      000004 F0               [24]  526 	movx	@dptr,a
                                    527 ;	usb.c:33: USB[EPINDEX] = EP0;                          // Change to EP0 
      000005 90 FF F1         [24]  528 	mov	dptr,#0xfff1
      000008 F0               [24]  529 	movx	@dptr,a
                                    530 ;	usb.c:34: USB[EPCON] = ( TXEPEN | RXEPEN );            // Enable Tx & Rx
                                    531 ;	usb.c:35: USB[EPCON] |= ( TXSTL | RXSTL );             // Set RXSTL & TXSTL (prevent not SETUP Token)
      000009 90 FF E1         [24]  532 	mov	dptr,#0xffe1
      00000C 74 05            [12]  533 	mov	a,#0x05
      00000E F0               [24]  534 	movx	@dptr,a
      00000F E0               [24]  535 	movx	a,@dptr
      000010 FF               [12]  536 	mov	r7,a
      000011 43 07 C0         [24]  537 	orl	ar7,#0xc0
      000014 90 FF E1         [24]  538 	mov	dptr,#0xffe1
      000017 EF               [12]  539 	mov	a,r7
      000018 F0               [24]  540 	movx	@dptr,a
                                    541 ;	usb.c:36: USB[TXCON] = TXCLR;                          // Clear Tx FIFO
      000019 90 FF F4         [24]  542 	mov	dptr,#0xfff4
      00001C 74 80            [12]  543 	mov	a,#0x80
      00001E F0               [24]  544 	movx	@dptr,a
                                    545 ;	usb.c:37: USB[RXCON] = RXCLR;                          // Clear Rx FIFO
      00001F 90 FF E4         [24]  546 	mov	dptr,#0xffe4
      000022 F0               [24]  547 	movx	@dptr,a
                                    548 ;	usb.c:39: USB[UIE] = ( UTXIE0 | URXIE0 | UTXIE1 );   
      000023 90 FF DA         [24]  549 	mov	dptr,#0xffda
      000026 74 07            [12]  550 	mov	a,#0x07
      000028 F0               [24]  551 	movx	@dptr,a
                                    552 ;	usb.c:41: USB[IEN] = ( EF | EFSR );                    // Enable USB all related interrupts
      000029 90 FF D9         [24]  553 	mov	dptr,#0xffd9
      00002C 14               [12]  554 	dec	a
      00002D F0               [24]  555 	movx	@dptr,a
                                    556 ;	usb.c:43: Ep0.Unit = EP0_MAX;                          // 
      00002E 75*12 08         [24]  557 	mov	(_Ep0 + 0x000f),#0x08
                                    558 ;	usb.c:44: Ep0.EmuOk = CLR;                             // Check Emulation status
      000031 75*04 00         [24]  559 	mov	(_Ep0 + 0x0001),#0x00
                                    560 ;	usb.c:45: Ep0.RWEN = CLR;                              // Remote/Wakeup flag ( Default " Disable " )
      000034 75*03 00         [24]  561 	mov	_Ep0,#0x00
                                    562 ;	usb.c:47: USB[UPCON] |= CONEN;                         // Connecter to Host ( Enable the pull-up resistor )
      000037 90 FF C9         [24]  563 	mov	dptr,#0xffc9
      00003A E0               [24]  564 	movx	a,@dptr
      00003B 44 80            [12]  565 	orl	a,#0x80
      00003D F0               [24]  566 	movx	@dptr,a
                                    567 ;	usb.c:48: }
      00003E 22               [24]  568 	ret
                                    569 ;------------------------------------------------------------
                                    570 ;Allocation info for local variables in function 'USB_Rd_FIFO'
                                    571 ;------------------------------------------------------------
                                    572 ;Cnt                       Allocated with name '_USB_Rd_FIFO_PARM_2'
                                    573 ;Buffer                    Allocated to registers r5 r6 r7 
                                    574 ;i                         Allocated to registers r4 
                                    575 ;------------------------------------------------------------
                                    576 ;	usb.c:51: void USB_Rd_FIFO( BYTE *Buffer , BYTE Cnt ) { 
                                    577 ;	-----------------------------------------
                                    578 ;	 function USB_Rd_FIFO
                                    579 ;	-----------------------------------------
      00003F                        580 _USB_Rd_FIFO:
      00003F AD 82            [24]  581 	mov	r5,dpl
      000041 AE 83            [24]  582 	mov	r6,dph
      000043 AF F0            [24]  583 	mov	r7,b
                                    584 ;	usb.c:53: for (i = 0; i < Cnt; i++) {  
      000045 7C 00            [12]  585 	mov	r4,#0x00
      000047                        586 00103$:
      000047 C3               [12]  587 	clr	c
      000048 EC               [12]  588 	mov	a,r4
      000049 95*00            [12]  589 	subb	a,_USB_Rd_FIFO_PARM_2
      00004B 50 19            [24]  590 	jnc	00105$
                                    591 ;	usb.c:54: Buffer[i] = USB[RXDAT];
      00004D EC               [12]  592 	mov	a,r4
      00004E 2D               [12]  593 	add	a,r5
      00004F F9               [12]  594 	mov	r1,a
      000050 E4               [12]  595 	clr	a
      000051 3E               [12]  596 	addc	a,r6
      000052 FA               [12]  597 	mov	r2,a
      000053 8F 03            [24]  598 	mov	ar3,r7
      000055 90 FF E3         [24]  599 	mov	dptr,#0xffe3
      000058 E0               [24]  600 	movx	a,@dptr
      000059 F8               [12]  601 	mov	r0,a
      00005A 89 82            [24]  602 	mov	dpl,r1
      00005C 8A 83            [24]  603 	mov	dph,r2
      00005E 8B F0            [24]  604 	mov	b,r3
      000060 12r00r00         [24]  605 	lcall	__gptrput
                                    606 ;	usb.c:53: for (i = 0; i < Cnt; i++) {  
      000063 0C               [12]  607 	inc	r4
      000064 80 E1            [24]  608 	sjmp	00103$
      000066                        609 00105$:
                                    610 ;	usb.c:56: }
      000066 22               [24]  611 	ret
                                    612 ;------------------------------------------------------------
                                    613 ;Allocation info for local variables in function 'USB_Wr_FIFO'
                                    614 ;------------------------------------------------------------
                                    615 ;Cnt                       Allocated with name '_USB_Wr_FIFO_PARM_2'
                                    616 ;Buffer                    Allocated to registers r5 r6 r7 
                                    617 ;i                         Allocated to registers r4 
                                    618 ;------------------------------------------------------------
                                    619 ;	usb.c:59: void USB_Wr_FIFO( BYTE *Buffer , BYTE Cnt )
                                    620 ;	-----------------------------------------
                                    621 ;	 function USB_Wr_FIFO
                                    622 ;	-----------------------------------------
      000067                        623 _USB_Wr_FIFO:
      000067 AD 82            [24]  624 	mov	r5,dpl
      000069 AE 83            [24]  625 	mov	r6,dph
      00006B AF F0            [24]  626 	mov	r7,b
                                    627 ;	usb.c:63: for ( i=0 ; i<Cnt ; i++ )  
      00006D 7C 00            [12]  628 	mov	r4,#0x00
      00006F                        629 00103$:
      00006F C3               [12]  630 	clr	c
      000070 EC               [12]  631 	mov	a,r4
      000071 95*00            [12]  632 	subb	a,_USB_Wr_FIFO_PARM_2
      000073 50 19            [24]  633 	jnc	00105$
                                    634 ;	usb.c:64: USB[TXDAT] = Buffer[i];
      000075 EC               [12]  635 	mov	a,r4
      000076 2D               [12]  636 	add	a,r5
      000077 F9               [12]  637 	mov	r1,a
      000078 E4               [12]  638 	clr	a
      000079 3E               [12]  639 	addc	a,r6
      00007A FA               [12]  640 	mov	r2,a
      00007B 8F 03            [24]  641 	mov	ar3,r7
      00007D 89 82            [24]  642 	mov	dpl,r1
      00007F 8A 83            [24]  643 	mov	dph,r2
      000081 8B F0            [24]  644 	mov	b,r3
      000083 12r00r00         [24]  645 	lcall	__gptrget
      000086 F9               [12]  646 	mov	r1,a
      000087 90 FF F3         [24]  647 	mov	dptr,#0xfff3
      00008A F0               [24]  648 	movx	@dptr,a
                                    649 ;	usb.c:63: for ( i=0 ; i<Cnt ; i++ )  
      00008B 0C               [12]  650 	inc	r4
      00008C 80 E1            [24]  651 	sjmp	00103$
      00008E                        652 00105$:
                                    653 ;	usb.c:65: }
      00008E 22               [24]  654 	ret
                                    655 ;------------------------------------------------------------
                                    656 ;Allocation info for local variables in function 'USB_Ep0_FIFO'
                                    657 ;------------------------------------------------------------
                                    658 ;BLen                      Allocated to registers r7 
                                    659 ;------------------------------------------------------------
                                    660 ;	usb.c:68: void USB_Ep0_FIFO( void )
                                    661 ;	-----------------------------------------
                                    662 ;	 function USB_Ep0_FIFO
                                    663 ;	-----------------------------------------
      00008F                        664 _USB_Ep0_FIFO:
                                    665 ;	usb.c:72: USB[TXCON] = TXCLR;                          // Clear Tx FIFO
      00008F 90 FF F4         [24]  666 	mov	dptr,#0xfff4
      000092 74 80            [12]  667 	mov	a,#0x80
      000094 F0               [24]  668 	movx	@dptr,a
                                    669 ;	usb.c:74: if ( USB[RXSTAT] & ( STOVW | EDOVW ))        // Setup Token
      000095 90 FF E2         [24]  670 	mov	dptr,#0xffe2
      000098 E0               [24]  671 	movx	a,@dptr
      000099 FF               [12]  672 	mov	r7,a
      00009A 54 30            [12]  673 	anl	a,#0x30
      00009C 60 53            [24]  674 	jz	00119$
                                    675 ;	usb.c:75: { Ep0.Stage = SETUPSTAGE;
      00009E 75*05 F0         [24]  676 	mov	(_Ep0 + 0x0002),#0xf0
                                    677 ;	usb.c:77: { while(USB[RXSTAT] & STOVW);          // waiting STOVE = 0
      0000A1                        678 00101$:
      0000A1 90 FF E2         [24]  679 	mov	dptr,#0xffe2
      0000A4 E0               [24]  680 	movx	a,@dptr
      0000A5 FF               [12]  681 	mov	r7,a
      0000A6 20 E5 F8         [24]  682 	jb	acc.5,00101$
                                    683 ;	usb.c:78: while(!( USB[RXSTAT] & EDOVW ));     // waiting EDOVW = 1
      0000A9                        684 00104$:
      0000A9 90 FF E2         [24]  685 	mov	dptr,#0xffe2
      0000AC E0               [24]  686 	movx	a,@dptr
      0000AD 30 E4 F9         [24]  687 	jnb	acc.4,00104$
                                    688 ;	usb.c:79: USB[RXSTAT] &= ~EDOVW;               // Clear the EDOVW bit when reading the contents of the FIFO
      0000B0 90 FF E2         [24]  689 	mov	dptr,#0xffe2
      0000B3 E0               [24]  690 	movx	a,@dptr
      0000B4 54 EF            [12]  691 	anl	a,#0xef
      0000B6 F0               [24]  692 	movx	@dptr,a
                                    693 ;	usb.c:80: USB[UIFLG] = URXD0;                  // Write "1" to Clear this Flag
      0000B7 90 FF DB         [24]  694 	mov	dptr,#0xffdb
      0000BA 74 02            [12]  695 	mov	a,#0x02
      0000BC F0               [24]  696 	movx	@dptr,a
                                    697 ;	usb.c:81: BLen = USB[RXCNT];                   // Chk total Rx Data count in Byte
      0000BD 90 FF E6         [24]  698 	mov	dptr,#0xffe6
      0000C0 E0               [24]  699 	movx	a,@dptr
      0000C1 FF               [12]  700 	mov	r7,a
                                    701 ;	usb.c:82: USB_Rd_FIFO( Ep0.RxTx , BLen );
      0000C2 8F*00            [24]  702 	mov	_USB_Rd_FIFO_PARM_2,r7
      0000C4 90r00r06         [24]  703 	mov	dptr,#(_Ep0 + 0x0003)
      0000C7 75 F0 40         [24]  704 	mov	b,#0x40
      0000CA C0 07            [24]  705 	push	ar7
      0000CC 12r00r3F         [24]  706 	lcall	_USB_Rd_FIFO
      0000CF D0 07            [24]  707 	pop	ar7
                                    708 ;	usb.c:83: if (!(USB[RXSTAT] & ( STOVW | EDOVW )))
      0000D1 90 FF E2         [24]  709 	mov	dptr,#0xffe2
      0000D4 E0               [24]  710 	movx	a,@dptr
      0000D5 54 30            [12]  711 	anl	a,#0x30
      0000D7 60 02            [24]  712 	jz	00162$
      0000D9 80 C6            [24]  713 	sjmp	00101$
      0000DB                        714 00162$:
                                    715 ;	usb.c:86: USB[EPCON] &= ~( RXSTL | TXSTL );        // Release Rx/Tx STAL
      0000DB 90 FF E1         [24]  716 	mov	dptr,#0xffe1
      0000DE E0               [24]  717 	movx	a,@dptr
      0000DF 54 3F            [12]  718 	anl	a,#0x3f
      0000E1 F0               [24]  719 	movx	@dptr,a
                                    720 ;	usb.c:87: USB[RXSTAT] &= ~RXSETUP;                 // Release Setup Token flag
      0000E2 90 FF E2         [24]  721 	mov	dptr,#0xffe2
      0000E5 E0               [24]  722 	movx	a,@dptr
      0000E6 54 BF            [12]  723 	anl	a,#0xbf
      0000E8 F0               [24]  724 	movx	@dptr,a
                                    725 ;	usb.c:88: Ep0.All = BLen;                          // Only for analytic "Urd"
      0000E9 7E 00            [12]  726 	mov	r6,#0x00
      0000EB 8F*13            [24]  727 	mov	((_Ep0 + 0x0010) + 0),r7
      0000ED 8E*14            [24]  728 	mov	((_Ep0 + 0x0010) + 1),r6
      0000EF 80 52            [24]  729 	sjmp	00120$
      0000F1                        730 00119$:
                                    731 ;	usb.c:90: else if ( Ep0.Stage == DFU_STAGE )
      0000F1 74 33            [12]  732 	mov	a,#0x33
      0000F3 B5*05 42         [24]  733 	cjne	a,(_Ep0 + 0x0002),00116$
                                    734 ;	usb.c:91: { BLen = USB[RXCNT];                       // Chk total Rx Data count in Byte  
      0000F6 90 FF E6         [24]  735 	mov	dptr,#0xffe6
      0000F9 E0               [24]  736 	movx	a,@dptr
                                    737 ;	usb.c:92: Ep0.All -= BLen;
      0000FA FF               [12]  738 	mov	r7,a
      0000FB FD               [12]  739 	mov	r5,a
      0000FC 7E 00            [12]  740 	mov	r6,#0x00
      0000FE E5*13            [12]  741 	mov	a,(_Ep0 + 0x0010)
      000100 C3               [12]  742 	clr	c
      000101 9D               [12]  743 	subb	a,r5
      000102 FD               [12]  744 	mov	r5,a
      000103 E5*14            [12]  745 	mov	a,((_Ep0 + 0x0010) + 1)
      000105 9E               [12]  746 	subb	a,r6
      000106 FE               [12]  747 	mov	r6,a
      000107 8D*13            [24]  748 	mov	((_Ep0 + 0x0010) + 0),r5
      000109 8E*14            [24]  749 	mov	((_Ep0 + 0x0010) + 1),r6
                                    750 ;	usb.c:94: USB_Rd_FIFO( Ep0.RxTx , BLen );
      00010B 8F*00            [24]  751 	mov	_USB_Rd_FIFO_PARM_2,r7
      00010D 90r00r06         [24]  752 	mov	dptr,#(_Ep0 + 0x0003)
      000110 75 F0 40         [24]  753 	mov	b,#0x40
      000113 C0 07            [24]  754 	push	ar7
      000115 12r00r3F         [24]  755 	lcall	_USB_Rd_FIFO
      000118 D0 07            [24]  756 	pop	ar7
                                    757 ;	usb.c:95: if ( BLen == EP0_MAX )
      00011A BF 08 0B         [24]  758 	cjne	r7,#0x08,00113$
                                    759 ;	usb.c:96: { USB[TXCNT] = 0;
      00011D 90 FF F6         [24]  760 	mov	dptr,#0xfff6
      000120 E4               [12]  761 	clr	a
      000121 F0               [24]  762 	movx	@dptr,a
                                    763 ;	usb.c:97: Ep0.Stage = Ep0.RxTx[0];
      000122 AF*06            [24]  764 	mov	r7,(_Ep0 + 0x0003)
      000124 8F*05            [24]  765 	mov	(_Ep0 + 0x0002),r7
      000126 80 1B            [24]  766 	sjmp	00120$
      000128                        767 00113$:
                                    768 ;	usb.c:100: { LED_STATUS = Ep0.RxTx[0];
      000128 85*06*00         [24]  769 	mov	_LED_STATUS,(_Ep0 + 0x0003)
                                    770 ;	usb.c:101: KB_LED_Status();
      00012B 12r00r00         [24]  771 	lcall	_KB_LED_Status
                                    772 ;	usb.c:102: USB[TXCNT] = 0;
      00012E 90 FF F6         [24]  773 	mov	dptr,#0xfff6
      000131 E4               [12]  774 	clr	a
      000132 F0               [24]  775 	movx	@dptr,a
                                    776 ;	usb.c:103: Ep0.Stage = STATUSSTAGE;
      000133 75*05 A5         [24]  777 	mov	(_Ep0 + 0x0002),#0xa5
      000136 80 0B            [24]  778 	sjmp	00120$
      000138                        779 00116$:
                                    780 ;	usb.c:107: { Ep0.Stage = STATUSSTAGE;
      000138 75*05 A5         [24]  781 	mov	(_Ep0 + 0x0002),#0xa5
                                    782 ;	usb.c:108: USB[EPCON] |= ( RXSTL | TXSTL );         // Receive the host "ACK" transaction , we should set Rx/Tx STAL
      00013B 90 FF E1         [24]  783 	mov	dptr,#0xffe1
      00013E E0               [24]  784 	movx	a,@dptr
      00013F 44 C0            [12]  785 	orl	a,#0xc0
      000141 FF               [12]  786 	mov	r7,a
      000142 F0               [24]  787 	movx	@dptr,a
      000143                        788 00120$:
                                    789 ;	usb.c:111: USB[RXCON] |= RXFFRC;                        // Set this bit , meaning that Rx Data has Read Complete
      000143 90 FF E4         [24]  790 	mov	dptr,#0xffe4
      000146 E0               [24]  791 	movx	a,@dptr
      000147 44 10            [12]  792 	orl	a,#0x10
      000149 F0               [24]  793 	movx	@dptr,a
                                    794 ;	usb.c:112: }
      00014A 22               [24]  795 	ret
                                    796 ;------------------------------------------------------------
                                    797 ;Allocation info for local variables in function 'USB_Get_Status'
                                    798 ;------------------------------------------------------------
                                    799 ;	usb.c:115: void USB_Get_Status( void )
                                    800 ;	-----------------------------------------
                                    801 ;	 function USB_Get_Status
                                    802 ;	-----------------------------------------
      00014B                        803 _USB_Get_Status:
                                    804 ;	usb.c:116: { Ep0.All = 2;                                 // Only 2 byte transfer to the host
      00014B 75*13 02         [24]  805 	mov	((_Ep0 + 0x0010) + 0),#0x02
      00014E 75*14 00         [24]  806 	mov	((_Ep0 + 0x0010) + 1),#0x00
                                    807 ;	usb.c:119: Ep0.RxTx[1] = 0;
      000151 75*07 00         [24]  808 	mov	(_Ep0 + 0x0004),#0x00
                                    809 ;	usb.c:120: switch( Ep0.RxTx[0] & 0x03 )                 // Request Type ( Reserve low 2 bit )
      000154 AE*06            [24]  810 	mov	r6,(_Ep0 + 0x0003)
      000156 53 06 03         [24]  811 	anl	ar6,#0x03
      000159 7F 00            [12]  812 	mov	r7,#0x00
      00015B BE 00 05         [24]  813 	cjne	r6,#0x00,00135$
      00015E BF 00 02         [24]  814 	cjne	r7,#0x00,00135$
      000161 80 0F            [24]  815 	sjmp	00101$
      000163                        816 00135$:
      000163 BE 01 04         [24]  817 	cjne	r6,#0x01,00136$
      000166 BF 00 01         [24]  818 	cjne	r7,#0x00,00136$
      000169 22               [24]  819 	ret
      00016A                        820 00136$:
                                    821 ;	usb.c:121: { case DEVICEREQUEST:    if ( Ep0.RWEN )
      00016A BE 02 33         [24]  822 	cjne	r6,#0x02,00111$
      00016D BF 00 30         [24]  823 	cjne	r7,#0x00,00111$
      000170 80 0C            [24]  824 	sjmp	00105$
      000172                        825 00101$:
      000172 E5*03            [12]  826 	mov	a,_Ep0
      000174 60 04            [24]  827 	jz	00103$
                                    828 ;	usb.c:122: Ep0.RxTx[0] = 0x02;// Return Function Remove Wake-up Enable
      000176 75*06 02         [24]  829 	mov	(_Ep0 + 0x0003),#0x02
      000179 22               [24]  830 	ret
      00017A                        831 00103$:
                                    832 ;	usb.c:124: Ep0.RxTx[0] = 0x00;// Return Function Remove Wake-up Disable
      00017A 75*06 00         [24]  833 	mov	(_Ep0 + 0x0003),#0x00
                                    834 ;	usb.c:125: break;            // Chk Remote wakeup enabled or not
                                    835 ;	usb.c:126: case ENDPOINTREQUEST:  USB[EPINDEX] = Ep0.RxTx[4] & 0x0F;
      00017D 22               [24]  836 	ret
      00017E                        837 00105$:
      00017E 74 0F            [12]  838 	mov	a,#0x0f
      000180 55*0A            [12]  839 	anl	a,(_Ep0 + 0x0007)
      000182 90 FF F1         [24]  840 	mov	dptr,#0xfff1
      000185 F0               [24]  841 	movx	@dptr,a
                                    842 ;	usb.c:127: if (( USB[EPCON] & RXSTL )||( USB[EPCON] & TXSTL ))
      000186 90 FF E1         [24]  843 	mov	dptr,#0xffe1
      000189 E0               [24]  844 	movx	a,@dptr
      00018A FF               [12]  845 	mov	r7,a
      00018B 20 E7 04         [24]  846 	jb	acc.7,00106$
      00018E EF               [12]  847 	mov	a,r7
      00018F 30 E6 05         [24]  848 	jnb	acc.6,00107$
      000192                        849 00106$:
                                    850 ;	usb.c:128: Ep0.RxTx[0] = 0x01;// if EndPoint Rx/Tx STAL then set EndPoint Halt
      000192 75*06 01         [24]  851 	mov	(_Ep0 + 0x0003),#0x01
      000195 80 03            [24]  852 	sjmp	00108$
      000197                        853 00107$:
                                    854 ;	usb.c:130: Ep0.RxTx[0] = 0x00;// else seting this EndPoint Avaliable for Rx/Tx  
      000197 75*06 00         [24]  855 	mov	(_Ep0 + 0x0003),#0x00
      00019A                        856 00108$:
                                    857 ;	usb.c:131: USB[EPINDEX] = EP0;
      00019A 90 FF F1         [24]  858 	mov	dptr,#0xfff1
      00019D E4               [12]  859 	clr	a
      00019E F0               [24]  860 	movx	@dptr,a
                                    861 ;	usb.c:132: break;
                                    862 ;	usb.c:134: default:               USB[EPCON] |= ( RXSTL | TXSTL );
      00019F 22               [24]  863 	ret
      0001A0                        864 00111$:
      0001A0 90 FF E1         [24]  865 	mov	dptr,#0xffe1
      0001A3 E0               [24]  866 	movx	a,@dptr
      0001A4 44 C0            [12]  867 	orl	a,#0xc0
      0001A6 F0               [24]  868 	movx	@dptr,a
                                    869 ;	usb.c:136: }
                                    870 ;	usb.c:137: }  	
      0001A7 22               [24]  871 	ret
                                    872 ;------------------------------------------------------------
                                    873 ;Allocation info for local variables in function 'USB_Clear_Feature'
                                    874 ;------------------------------------------------------------
                                    875 ;	usb.c:140: void USB_Clear_Feature( void )
                                    876 ;	-----------------------------------------
                                    877 ;	 function USB_Clear_Feature
                                    878 ;	-----------------------------------------
      0001A8                        879 _USB_Clear_Feature:
                                    880 ;	usb.c:141: { switch( Ep0.RxTx[0] & 0x03 )                 // Request Type ( Reserve low 2 bit )
      0001A8 AE*06            [24]  881 	mov	r6,(_Ep0 + 0x0003)
      0001AA 53 06 03         [24]  882 	anl	ar6,#0x03
      0001AD 7F 00            [12]  883 	mov	r7,#0x00
      0001AF BE 00 05         [24]  884 	cjne	r6,#0x00,00134$
      0001B2 BF 00 02         [24]  885 	cjne	r7,#0x00,00134$
      0001B5 80 0F            [24]  886 	sjmp	00101$
      0001B7                        887 00134$:
      0001B7 BE 01 04         [24]  888 	cjne	r6,#0x01,00135$
      0001BA BF 00 01         [24]  889 	cjne	r7,#0x00,00135$
      0001BD 22               [24]  890 	ret
      0001BE                        891 00135$:
                                    892 ;	usb.c:142: { case DEVICEREQUEST:    if ( Ep0.RxTx[2] == DEVICE_REMOTE_WAKEUP )
      0001BE BE 02 41         [24]  893 	cjne	r6,#0x02,00110$
      0001C1 BF 00 3E         [24]  894 	cjne	r7,#0x00,00110$
      0001C4 80 11            [24]  895 	sjmp	00105$
      0001C6                        896 00101$:
      0001C6 74 01            [12]  897 	mov	a,#0x01
      0001C8 B5*08 04         [24]  898 	cjne	a,(_Ep0 + 0x0005),00103$
                                    899 ;	usb.c:143: Ep0.RWEN = CLR;
      0001CB 75*03 00         [24]  900 	mov	_Ep0,#0x00
      0001CE 22               [24]  901 	ret
      0001CF                        902 00103$:
                                    903 ;	usb.c:145: USB[EPCON] |= ( RXSTL | TXSTL );
      0001CF 90 FF E1         [24]  904 	mov	dptr,#0xffe1
      0001D2 E0               [24]  905 	movx	a,@dptr
      0001D3 44 C0            [12]  906 	orl	a,#0xc0
      0001D5 F0               [24]  907 	movx	@dptr,a
                                    908 ;	usb.c:146: break;            // Disable the Device Remote Wakeup function
                                    909 ;	usb.c:147: case ENDPOINTREQUEST:  if ( Ep0.RxTx[2] == ENDPOINT_HALT )
      0001D6 22               [24]  910 	ret
      0001D7                        911 00105$:
      0001D7 E5*08            [12]  912 	mov	a,(_Ep0 + 0x0005)
      0001D9 70 1F            [24]  913 	jnz	00107$
                                    914 ;	usb.c:148: { USB[EPINDEX] = Ep0.RxTx[4] & 0x0F;
      0001DB 74 0F            [12]  915 	mov	a,#0x0f
      0001DD 55*0A            [12]  916 	anl	a,(_Ep0 + 0x0007)
      0001DF 90 FF F1         [24]  917 	mov	dptr,#0xfff1
      0001E2 F0               [24]  918 	movx	@dptr,a
                                    919 ;	usb.c:149: USB[EPCON] &= ~( RXSTL | TXSTL );
      0001E3 90 FF E1         [24]  920 	mov	dptr,#0xffe1
      0001E6 E0               [24]  921 	movx	a,@dptr
      0001E7 54 3F            [12]  922 	anl	a,#0x3f
      0001E9 F0               [24]  923 	movx	@dptr,a
                                    924 ;	usb.c:150: USB[RXSTAT] = RXSOVW;// Enable RXSEQ/TXSEQ bit can be Updata , and
      0001EA 90 FF E2         [24]  925 	mov	dptr,#0xffe2
      0001ED 74 08            [12]  926 	mov	a,#0x08
      0001EF F0               [24]  927 	movx	@dptr,a
                                    928 ;	usb.c:151: USB[TXSTAT] = TXSOVW;// set Rx/Tx toggle buffer into DATA0
      0001F0 90 FF F2         [24]  929 	mov	dptr,#0xfff2
      0001F3 F0               [24]  930 	movx	@dptr,a
                                    931 ;	usb.c:152: USB[EPINDEX] = EP0;
      0001F4 90 FF F1         [24]  932 	mov	dptr,#0xfff1
      0001F7 E4               [12]  933 	clr	a
      0001F8 F0               [24]  934 	movx	@dptr,a
      0001F9 22               [24]  935 	ret
      0001FA                        936 00107$:
                                    937 ;	usb.c:155: USB[EPCON] |= ( RXSTL | TXSTL );
      0001FA 90 FF E1         [24]  938 	mov	dptr,#0xffe1
      0001FD E0               [24]  939 	movx	a,@dptr
      0001FE 44 C0            [12]  940 	orl	a,#0xc0
      000200 F0               [24]  941 	movx	@dptr,a
                                    942 ;	usb.c:156: break;
                                    943 ;	usb.c:158: default:               USB[EPCON] |= ( RXSTL | TXSTL );
      000201 22               [24]  944 	ret
      000202                        945 00110$:
      000202 90 FF E1         [24]  946 	mov	dptr,#0xffe1
      000205 E0               [24]  947 	movx	a,@dptr
      000206 44 C0            [12]  948 	orl	a,#0xc0
      000208 F0               [24]  949 	movx	@dptr,a
                                    950 ;	usb.c:160: }
                                    951 ;	usb.c:161: }
      000209 22               [24]  952 	ret
                                    953 ;------------------------------------------------------------
                                    954 ;Allocation info for local variables in function 'USB_Set_Feature'
                                    955 ;------------------------------------------------------------
                                    956 ;	usb.c:164: void USB_Set_Feature( void )
                                    957 ;	-----------------------------------------
                                    958 ;	 function USB_Set_Feature
                                    959 ;	-----------------------------------------
      00020A                        960 _USB_Set_Feature:
                                    961 ;	usb.c:165: { switch( Ep0.RxTx[0] & 0x03 )                 // Request Type ( Reserve low 2 bit )
      00020A AE*06            [24]  962 	mov	r6,(_Ep0 + 0x0003)
      00020C 53 06 03         [24]  963 	anl	ar6,#0x03
      00020F 7F 00            [12]  964 	mov	r7,#0x00
      000211 BE 00 05         [24]  965 	cjne	r6,#0x00,00134$
      000214 BF 00 02         [24]  966 	cjne	r7,#0x00,00134$
      000217 80 0F            [24]  967 	sjmp	00101$
      000219                        968 00134$:
      000219 BE 01 04         [24]  969 	cjne	r6,#0x01,00135$
      00021C BF 00 01         [24]  970 	cjne	r7,#0x00,00135$
      00021F 22               [24]  971 	ret
      000220                        972 00135$:
                                    973 ;	usb.c:166: { case DEVICEREQUEST:    if ( Ep0.RxTx[2] == DEVICE_REMOTE_WAKEUP )
      000220 BE 02 37         [24]  974 	cjne	r6,#0x02,00110$
      000223 BF 00 34         [24]  975 	cjne	r7,#0x00,00110$
      000226 80 11            [24]  976 	sjmp	00105$
      000228                        977 00101$:
      000228 74 01            [12]  978 	mov	a,#0x01
      00022A B5*08 04         [24]  979 	cjne	a,(_Ep0 + 0x0005),00103$
                                    980 ;	usb.c:167: Ep0.RWEN = SET;
      00022D 75*03 01         [24]  981 	mov	_Ep0,#0x01
      000230 22               [24]  982 	ret
      000231                        983 00103$:
                                    984 ;	usb.c:169: USB[EPCON] |= ( RXSTL | TXSTL );
      000231 90 FF E1         [24]  985 	mov	dptr,#0xffe1
      000234 E0               [24]  986 	movx	a,@dptr
      000235 44 C0            [12]  987 	orl	a,#0xc0
      000237 F0               [24]  988 	movx	@dptr,a
                                    989 ;	usb.c:170: break;            // Disable the Device Remote Wakeup function
                                    990 ;	usb.c:171: case ENDPOINTREQUEST:  if ( Ep0.RxTx[2] == ENDPOINT_HALT )
      000238 22               [24]  991 	ret
      000239                        992 00105$:
      000239 E5*08            [12]  993 	mov	a,(_Ep0 + 0x0005)
      00023B 70 15            [24]  994 	jnz	00107$
                                    995 ;	usb.c:172: { USB[EPINDEX] = Ep0.RxTx[4] & 0x0F;
      00023D 74 0F            [12]  996 	mov	a,#0x0f
      00023F 55*0A            [12]  997 	anl	a,(_Ep0 + 0x0007)
      000241 90 FF F1         [24]  998 	mov	dptr,#0xfff1
      000244 F0               [24]  999 	movx	@dptr,a
                                   1000 ;	usb.c:173: USB[EPCON] |= ( RXSTL | TXSTL );
      000245 90 FF E1         [24] 1001 	mov	dptr,#0xffe1
      000248 E0               [24] 1002 	movx	a,@dptr
      000249 44 C0            [12] 1003 	orl	a,#0xc0
      00024B F0               [24] 1004 	movx	@dptr,a
                                   1005 ;	usb.c:174: USB[EPINDEX] = EP0;
      00024C 90 FF F1         [24] 1006 	mov	dptr,#0xfff1
      00024F E4               [12] 1007 	clr	a
      000250 F0               [24] 1008 	movx	@dptr,a
      000251 22               [24] 1009 	ret
      000252                       1010 00107$:
                                   1011 ;	usb.c:177: USB[EPCON] |= ( RXSTL | TXSTL );
      000252 90 FF E1         [24] 1012 	mov	dptr,#0xffe1
      000255 E0               [24] 1013 	movx	a,@dptr
      000256 44 C0            [12] 1014 	orl	a,#0xc0
      000258 F0               [24] 1015 	movx	@dptr,a
                                   1016 ;	usb.c:178: break;
                                   1017 ;	usb.c:180: default:               USB[EPCON] |= ( RXSTL | TXSTL );
      000259 22               [24] 1018 	ret
      00025A                       1019 00110$:
      00025A 90 FF E1         [24] 1020 	mov	dptr,#0xffe1
      00025D E0               [24] 1021 	movx	a,@dptr
      00025E 44 C0            [12] 1022 	orl	a,#0xc0
      000260 F0               [24] 1023 	movx	@dptr,a
                                   1024 ;	usb.c:182: }
                                   1025 ;	usb.c:183: }  
      000261 22               [24] 1026 	ret
                                   1027 ;------------------------------------------------------------
                                   1028 ;Allocation info for local variables in function 'USB_Get_Descriptor'
                                   1029 ;------------------------------------------------------------
                                   1030 ;WLen                      Allocated with name '_USB_Get_Descriptor_WLen_65536_35'
                                   1031 ;------------------------------------------------------------
                                   1032 ;	usb.c:186: void USB_Get_Descriptor( void )
                                   1033 ;	-----------------------------------------
                                   1034 ;	 function USB_Get_Descriptor
                                   1035 ;	-----------------------------------------
      000262                       1036 _USB_Get_Descriptor:
                                   1037 ;	usb.c:190: WLen.B[0] = 0x00;                            // MSB
      000262 75*00 00         [24] 1038 	mov	_USB_Get_Descriptor_WLen_65536_35,#0x00
                                   1039 ;	usb.c:191: Ep0.All = Ep0.RxTx[7];                       // MSB
      000265 AE*0D            [24] 1040 	mov	r6,(_Ep0 + 0x000a)
      000267 7F 00            [12] 1041 	mov	r7,#0x00
      000269 8E*13            [24] 1042 	mov	((_Ep0 + 0x0010) + 0),r6
      00026B 8F*14            [24] 1043 	mov	((_Ep0 + 0x0010) + 1),r7
                                   1044 ;	usb.c:192: Ep0.All <<= 8;
      00026D 8E 07            [24] 1045 	mov	ar7,r6
      00026F 7E 00            [12] 1046 	mov	r6,#0x00
      000271 8E*13            [24] 1047 	mov	((_Ep0 + 0x0010) + 0),r6
      000273 8F*14            [24] 1048 	mov	((_Ep0 + 0x0010) + 1),r7
                                   1049 ;	usb.c:193: Ep0.All += Ep0.RxTx[6];                      // LSB
      000275 AC*0C            [24] 1050 	mov	r4,(_Ep0 + 0x0009)
      000277 7D 00            [12] 1051 	mov	r5,#0x00
      000279 EC               [12] 1052 	mov	a,r4
      00027A 2E               [12] 1053 	add	a,r6
      00027B FE               [12] 1054 	mov	r6,a
      00027C ED               [12] 1055 	mov	a,r5
      00027D 3F               [12] 1056 	addc	a,r7
      00027E FF               [12] 1057 	mov	r7,a
      00027F 8E*13            [24] 1058 	mov	((_Ep0 + 0x0010) + 0),r6
      000281 8F*14            [24] 1059 	mov	((_Ep0 + 0x0010) + 1),r7
                                   1060 ;	usb.c:194: switch( Ep0.RxTx[3] ) { 
      000283 AF*09            [24] 1061 	mov	r7,(_Ep0 + 0x0006)
      000285 BF 01 02         [24] 1062 	cjne	r7,#0x01,00167$
      000288 80 19            [24] 1063 	sjmp	00101$
      00028A                       1064 00167$:
      00028A BF 02 02         [24] 1065 	cjne	r7,#0x02,00168$
      00028D 80 28            [24] 1066 	sjmp	00102$
      00028F                       1067 00168$:
      00028F BF 03 02         [24] 1068 	cjne	r7,#0x03,00169$
      000292 80 3B            [24] 1069 	sjmp	00103$
      000294                       1070 00169$:
      000294 BF 21 03         [24] 1071 	cjne	r7,#0x21,00170$
      000297 02r03r5F         [24] 1072 	ljmp	00119$
      00029A                       1073 00170$:
      00029A BF 22 03         [24] 1074 	cjne	r7,#0x22,00171$
      00029D 02r03r72         [24] 1075 	ljmp	00120$
      0002A0                       1076 00171$:
      0002A0 02r03r8D         [24] 1077 	ljmp	00121$
                                   1078 ;	usb.c:195: case DEVICEDESCRIPTOR:        
      0002A3                       1079 00101$:
                                   1080 ;	usb.c:196: Ep0.Buf = (void *)DEVICE_DESCRIPTOR;
      0002A3 75*0Er49         [24] 1081 	mov	((_Ep0 + 0x000b) + 0),#_DEVICE_DESCRIPTOR
      0002A6 75*0Fs00         [24] 1082 	mov	((_Ep0 + 0x000b) + 1),#(_DEVICE_DESCRIPTOR >> 8)
      0002A9 75*10 80         [24] 1083 	mov	((_Ep0 + 0x000b) + 2),#0x80
                                   1084 ;	usb.c:197: WLen.B[1] = Ep0.Buf[0];
      0002AC 90r00r49         [24] 1085 	mov	dptr,#_DEVICE_DESCRIPTOR
      0002AF E4               [12] 1086 	clr	a
      0002B0 93               [24] 1087 	movc	a,@a+dptr
      0002B1 FF               [12] 1088 	mov	r7,a
      0002B2 8F*01            [24] 1089 	mov	(_USB_Get_Descriptor_WLen_65536_35 + 0x0001),r7
                                   1090 ;	usb.c:198: break;
      0002B4 02r03r95         [24] 1091 	ljmp	00122$
                                   1092 ;	usb.c:199: case CONFIGURATIONDESCRIPTOR: 
      0002B7                       1093 00102$:
                                   1094 ;	usb.c:200: Ep0.Buf = (void *)CONGFIGURATION_DESCRIPTOR;
      0002B7 75*0Er5B         [24] 1095 	mov	((_Ep0 + 0x000b) + 0),#_CONGFIGURATION_DESCRIPTOR
      0002BA 75*0Fs00         [24] 1096 	mov	((_Ep0 + 0x000b) + 1),#(_CONGFIGURATION_DESCRIPTOR >> 8)
      0002BD 75*10 80         [24] 1097 	mov	((_Ep0 + 0x000b) + 2),#0x80
                                   1098 ;	usb.c:201: WLen.B[1] = Ep0.Buf[2];// LSB
      0002C0 90r00r5D         [24] 1099 	mov	dptr,#(_CONGFIGURATION_DESCRIPTOR + 0x0002)
      0002C3 75 F0 80         [24] 1100 	mov	b,#0x80
      0002C6 12r00r00         [24] 1101 	lcall	__gptrget
      0002C9 FF               [12] 1102 	mov	r7,a
      0002CA 8F*01            [24] 1103 	mov	(_USB_Get_Descriptor_WLen_65536_35 + 0x0001),r7
                                   1104 ;	usb.c:202: break;
      0002CC 02r03r95         [24] 1105 	ljmp	00122$
                                   1106 ;	usb.c:203: case STRINGDESCRIPTOR:        
      0002CF                       1107 00103$:
                                   1108 ;	usb.c:204: switch( Ep0.RxTx[2] ) { 
      0002CF E5*08            [12] 1109 	mov	a,(_Ep0 + 0x0005)
      0002D1 FF               [12] 1110 	mov	r7,a
      0002D2 24 FC            [12] 1111 	add	a,#0xff - 0x03
      0002D4 50 03            [24] 1112 	jnc	00172$
      0002D6 02r03r46         [24] 1113 	ljmp	00117$
      0002D9                       1114 00172$:
      0002D9 EF               [12] 1115 	mov	a,r7
      0002DA 2F               [12] 1116 	add	a,r7
                                   1117 ;	usb.c:205: case 0:  
      0002DB 90r02rDF         [24] 1118 	mov	dptr,#00173$
      0002DE 73               [24] 1119 	jmp	@a+dptr
      0002DF                       1120 00173$:
      0002DF 80 06            [24] 1121 	sjmp	00104$
      0002E1 80 0F            [24] 1122 	sjmp	00105$
      0002E3 80 29            [24] 1123 	sjmp	00109$
      0002E5 80 43            [24] 1124 	sjmp	00113$
      0002E7                       1125 00104$:
                                   1126 ;	usb.c:206: Ep0.Buf = (void *)LANGUAGEID_DESCRIPTOR;
      0002E7 75*0Er7D         [24] 1127 	mov	((_Ep0 + 0x000b) + 0),#_LANGUAGEID_DESCRIPTOR
      0002EA 75*0Fs00         [24] 1128 	mov	((_Ep0 + 0x000b) + 1),#(_LANGUAGEID_DESCRIPTOR >> 8)
      0002ED 75*10 80         [24] 1129 	mov	((_Ep0 + 0x000b) + 2),#0x80
                                   1130 ;	usb.c:207: break;
                                   1131 ;	usb.c:208: case 1:  
      0002F0 80 5C            [24] 1132 	sjmp	00118$
      0002F2                       1133 00105$:
                                   1134 ;	usb.c:209: if ( DEVICE_DESCRIPTOR[14] )
      0002F2 90r00r57         [24] 1135 	mov	dptr,#(_DEVICE_DESCRIPTOR + 0x000e)
      0002F5 E4               [12] 1136 	clr	a
      0002F6 93               [24] 1137 	movc	a,@a+dptr
      0002F7 60 0B            [24] 1138 	jz	00107$
                                   1139 ;	usb.c:210: Ep0.Buf = (void *)MANUFACTURER_DESCRIPTOR;
      0002F9 75*0Er81         [24] 1140 	mov	((_Ep0 + 0x000b) + 0),#_MANUFACTURER_DESCRIPTOR
      0002FC 75*0Fs00         [24] 1141 	mov	((_Ep0 + 0x000b) + 1),#(_MANUFACTURER_DESCRIPTOR >> 8)
      0002FF 75*10 80         [24] 1142 	mov	((_Ep0 + 0x000b) + 2),#0x80
      000302 80 4A            [24] 1143 	sjmp	00118$
      000304                       1144 00107$:
                                   1145 ;	usb.c:212: USB[EPCON] |= ( RXSTL | TXSTL );
      000304 90 FF E1         [24] 1146 	mov	dptr,#0xffe1
      000307 E0               [24] 1147 	movx	a,@dptr
      000308 44 C0            [12] 1148 	orl	a,#0xc0
      00030A FF               [12] 1149 	mov	r7,a
      00030B F0               [24] 1150 	movx	@dptr,a
                                   1151 ;	usb.c:213: break;
                                   1152 ;	usb.c:214: case 2:  
      00030C 80 40            [24] 1153 	sjmp	00118$
      00030E                       1154 00109$:
                                   1155 ;	usb.c:215: if ( DEVICE_DESCRIPTOR[15] )
      00030E 90r00r58         [24] 1156 	mov	dptr,#(_DEVICE_DESCRIPTOR + 0x000f)
      000311 E4               [12] 1157 	clr	a
      000312 93               [24] 1158 	movc	a,@a+dptr
      000313 60 0B            [24] 1159 	jz	00111$
                                   1160 ;	usb.c:216: Ep0.Buf = (void *)PRODUCT_DESCRIPTOR;
      000315 75*0ErA7         [24] 1161 	mov	((_Ep0 + 0x000b) + 0),#_PRODUCT_DESCRIPTOR
      000318 75*0Fs00         [24] 1162 	mov	((_Ep0 + 0x000b) + 1),#(_PRODUCT_DESCRIPTOR >> 8)
      00031B 75*10 80         [24] 1163 	mov	((_Ep0 + 0x000b) + 2),#0x80
      00031E 80 2E            [24] 1164 	sjmp	00118$
      000320                       1165 00111$:
                                   1166 ;	usb.c:218: USB[EPCON] |= ( RXSTL | TXSTL );
      000320 90 FF E1         [24] 1167 	mov	dptr,#0xffe1
      000323 E0               [24] 1168 	movx	a,@dptr
      000324 44 C0            [12] 1169 	orl	a,#0xc0
      000326 FF               [12] 1170 	mov	r7,a
      000327 F0               [24] 1171 	movx	@dptr,a
                                   1172 ;	usb.c:219: break;
                                   1173 ;	usb.c:220: case 3:  
      000328 80 24            [24] 1174 	sjmp	00118$
      00032A                       1175 00113$:
                                   1176 ;	usb.c:221: if ( DEVICE_DESCRIPTOR[16] )
      00032A 90r00r59         [24] 1177 	mov	dptr,#(_DEVICE_DESCRIPTOR + 0x0010)
      00032D E4               [12] 1178 	clr	a
      00032E 93               [24] 1179 	movc	a,@a+dptr
      00032F 60 0B            [24] 1180 	jz	00115$
                                   1181 ;	usb.c:222: Ep0.Buf = (void *)SERIALNUMBER_DESCRIPTOR;
      000331 75*0ErEB         [24] 1182 	mov	((_Ep0 + 0x000b) + 0),#_SERIALNUMBER_DESCRIPTOR
      000334 75*0Fs00         [24] 1183 	mov	((_Ep0 + 0x000b) + 1),#(_SERIALNUMBER_DESCRIPTOR >> 8)
      000337 75*10 80         [24] 1184 	mov	((_Ep0 + 0x000b) + 2),#0x80
      00033A 80 12            [24] 1185 	sjmp	00118$
      00033C                       1186 00115$:
                                   1187 ;	usb.c:224: USB[EPCON] |= ( RXSTL | TXSTL );
      00033C 90 FF E1         [24] 1188 	mov	dptr,#0xffe1
      00033F E0               [24] 1189 	movx	a,@dptr
      000340 44 C0            [12] 1190 	orl	a,#0xc0
      000342 FF               [12] 1191 	mov	r7,a
      000343 F0               [24] 1192 	movx	@dptr,a
                                   1193 ;	usb.c:225: break;
                                   1194 ;	usb.c:226: default: USB[EPCON] |= ( RXSTL | TXSTL );
      000344 80 08            [24] 1195 	sjmp	00118$
      000346                       1196 00117$:
      000346 90 FF E1         [24] 1197 	mov	dptr,#0xffe1
      000349 E0               [24] 1198 	movx	a,@dptr
      00034A 44 C0            [12] 1199 	orl	a,#0xc0
      00034C FF               [12] 1200 	mov	r7,a
      00034D F0               [24] 1201 	movx	@dptr,a
                                   1202 ;	usb.c:228: }
      00034E                       1203 00118$:
                                   1204 ;	usb.c:229: WLen.B[1] = Ep0.Buf[0];
      00034E 85*0E 82         [24] 1205 	mov	dpl,(_Ep0 + 0x000b)
      000351 85*0F 83         [24] 1206 	mov	dph,((_Ep0 + 0x000b) + 1)
      000354 85*10 F0         [24] 1207 	mov	b,((_Ep0 + 0x000b) + 2)
      000357 12r00r00         [24] 1208 	lcall	__gptrget
      00035A FF               [12] 1209 	mov	r7,a
      00035B 8F*01            [24] 1210 	mov	(_USB_Get_Descriptor_WLen_65536_35 + 0x0001),r7
                                   1211 ;	usb.c:230: break;
                                   1212 ;	usb.c:231: case HIDDESCRIPTOR:           
      00035D 80 36            [24] 1213 	sjmp	00122$
      00035F                       1214 00119$:
                                   1215 ;	usb.c:232: Ep0.Buf = (void *)KB_HID_DESCRIPTOR;
      00035F 75*0Er6D         [24] 1216 	mov	((_Ep0 + 0x000b) + 0),#_KB_HID_DESCRIPTOR
      000362 75*0Fs00         [24] 1217 	mov	((_Ep0 + 0x000b) + 1),#(_KB_HID_DESCRIPTOR >> 8)
      000365 75*10 80         [24] 1218 	mov	((_Ep0 + 0x000b) + 2),#0x80
                                   1219 ;	usb.c:233: WLen.B[1] = Ep0.Buf[0];
      000368 90r00r6D         [24] 1220 	mov	dptr,#_KB_HID_DESCRIPTOR
      00036B E4               [12] 1221 	clr	a
      00036C 93               [24] 1222 	movc	a,@a+dptr
      00036D FF               [12] 1223 	mov	r7,a
      00036E 8F*01            [24] 1224 	mov	(_USB_Get_Descriptor_WLen_65536_35 + 0x0001),r7
                                   1225 ;	usb.c:234: break;
                                   1226 ;	usb.c:235: case HIDREPORT:               
      000370 80 23            [24] 1227 	sjmp	00122$
      000372                       1228 00120$:
                                   1229 ;	usb.c:236: Ep0.Buf = (void *)KB_HID_REPORT;
      000372 75*0Er00         [24] 1230 	mov	((_Ep0 + 0x000b) + 0),#_KB_HID_REPORT
      000375 75*0Fs00         [24] 1231 	mov	((_Ep0 + 0x000b) + 1),#(_KB_HID_REPORT >> 8)
      000378 75*10 80         [24] 1232 	mov	((_Ep0 + 0x000b) + 2),#0x80
                                   1233 ;	usb.c:237: WLen.B[1] = KB_HID_DESCRIPTOR[7];
      00037B 90r00r74         [24] 1234 	mov	dptr,#(_KB_HID_DESCRIPTOR + 0x0007)
      00037E E4               [12] 1235 	clr	a
      00037F 93               [24] 1236 	movc	a,@a+dptr
      000380 FF               [12] 1237 	mov	r7,a
      000381 8F*01            [24] 1238 	mov	(_USB_Get_Descriptor_WLen_65536_35 + 0x0001),r7
                                   1239 ;	usb.c:238: WLen.B[0] = KB_HID_DESCRIPTOR[8];
      000383 90r00r75         [24] 1240 	mov	dptr,#(_KB_HID_DESCRIPTOR + 0x0008)
      000386 E4               [12] 1241 	clr	a
      000387 93               [24] 1242 	movc	a,@a+dptr
      000388 FF               [12] 1243 	mov	r7,a
      000389 8F*00            [24] 1244 	mov	_USB_Get_Descriptor_WLen_65536_35,r7
                                   1245 ;	usb.c:239: break;
                                   1246 ;	usb.c:240: default:                      
      00038B 80 08            [24] 1247 	sjmp	00122$
      00038D                       1248 00121$:
                                   1249 ;	usb.c:241: USB[EPCON] |= ( RXSTL | TXSTL );
      00038D 90 FF E1         [24] 1250 	mov	dptr,#0xffe1
      000390 E0               [24] 1251 	movx	a,@dptr
      000391 44 C0            [12] 1252 	orl	a,#0xc0
      000393 FF               [12] 1253 	mov	r7,a
      000394 F0               [24] 1254 	movx	@dptr,a
                                   1255 ;	usb.c:243: }
      000395                       1256 00122$:
                                   1257 ;	usb.c:245: if (Ep0.All > WLen.W)
      000395 C3               [12] 1258 	clr	c
      000396 E5*00            [12] 1259 	mov	a,_USB_Get_Descriptor_WLen_65536_35
      000398 95*13            [12] 1260 	subb	a,(_Ep0 + 0x0010)
      00039A E5*01            [12] 1261 	mov	a,(_USB_Get_Descriptor_WLen_65536_35 + 1)
      00039C 95*14            [12] 1262 	subb	a,((_Ep0 + 0x0010) + 1)
      00039E 50 06            [24] 1263 	jnc	00125$
                                   1264 ;	usb.c:246: Ep0.All = WLen.W;
      0003A0 85*00*13         [24] 1265 	mov	((_Ep0 + 0x0010) + 0),_USB_Get_Descriptor_WLen_65536_35
      0003A3 85*01*14         [24] 1266 	mov	((_Ep0 + 0x0010) + 1),(_USB_Get_Descriptor_WLen_65536_35 + 1)
      0003A6                       1267 00125$:
                                   1268 ;	usb.c:247: }
      0003A6 22               [24] 1269 	ret
                                   1270 ;------------------------------------------------------------
                                   1271 ;Allocation info for local variables in function 'USB_Set_Configuration'
                                   1272 ;------------------------------------------------------------
                                   1273 ;i                         Allocated to registers r7 
                                   1274 ;------------------------------------------------------------
                                   1275 ;	usb.c:250: void USB_Set_Configuration( void )
                                   1276 ;	-----------------------------------------
                                   1277 ;	 function USB_Set_Configuration
                                   1278 ;	-----------------------------------------
      0003A7                       1279 _USB_Set_Configuration:
                                   1280 ;	usb.c:254: Ep0.Tmp = Ep0.RxTx[2];
      0003A7 AF*08            [24] 1281 	mov	r7,(_Ep0 + 0x0005)
                                   1282 ;	usb.c:255: if ( Ep0.Tmp )
      0003A9 EF               [12] 1283 	mov	a,r7
      0003AA F5*15            [12] 1284 	mov	(_Ep0 + 0x0012),a
      0003AC 60 2B            [24] 1285 	jz	00115$
                                   1286 ;	usb.c:256: { for ( i=1 ; i<6 ; i++ )
      0003AE 7F 01            [12] 1287 	mov	r7,#0x01
      0003B0                       1288 00106$:
                                   1289 ;	usb.c:257: { USB[EPINDEX] = i;
      0003B0 90 FF F1         [24] 1290 	mov	dptr,#0xfff1
      0003B3 EF               [12] 1291 	mov	a,r7
      0003B4 F0               [24] 1292 	movx	@dptr,a
                                   1293 ;	usb.c:258: USB[EPCON] = ( TXEPEN | RXEPEN );   // Enable Receive Input/Transmit Output
      0003B5 90 FF E1         [24] 1294 	mov	dptr,#0xffe1
      0003B8 74 05            [12] 1295 	mov	a,#0x05
      0003BA F0               [24] 1296 	movx	@dptr,a
                                   1297 ;	usb.c:259: USB[RXCON] = RXCLR;                 // Clear Rx FIFO
      0003BB 90 FF E4         [24] 1298 	mov	dptr,#0xffe4
      0003BE 74 80            [12] 1299 	mov	a,#0x80
      0003C0 F0               [24] 1300 	movx	@dptr,a
                                   1301 ;	usb.c:260: USB[TXCON] = TXCLR;                 // Clear Tx FIFO
      0003C1 90 FF F4         [24] 1302 	mov	dptr,#0xfff4
      0003C4 F0               [24] 1303 	movx	@dptr,a
                                   1304 ;	usb.c:261: USB[RXSTAT] = RXSOVW;               // Enable RXSEQ/TXSEQ bit can be Updata , and
      0003C5 90 FF E2         [24] 1305 	mov	dptr,#0xffe2
      0003C8 C4               [12] 1306 	swap	a
      0003C9 F0               [24] 1307 	movx	@dptr,a
                                   1308 ;	usb.c:262: USB[TXSTAT] = TXSOVW;               // set Rx/Tx toggle buffer into DATA0
      0003CA 90 FF F2         [24] 1309 	mov	dptr,#0xfff2
      0003CD F0               [24] 1310 	movx	@dptr,a
                                   1311 ;	usb.c:256: { for ( i=1 ; i<6 ; i++ )
      0003CE 0F               [12] 1312 	inc	r7
      0003CF BF 06 00         [24] 1313 	cjne	r7,#0x06,00131$
      0003D2                       1314 00131$:
      0003D2 40 DC            [24] 1315 	jc	00106$
                                   1316 ;	usb.c:264: Ep0.EmuOk = SET;                         // Emulation Flow pass
      0003D4 75*04 01         [24] 1317 	mov	(_Ep0 + 0x0001),#0x01
                                   1318 ;	usb.c:267: { for ( i=1 ; i<6 ; i++ )
      0003D7 80 12            [24] 1319 	sjmp	00105$
      0003D9                       1320 00115$:
      0003D9 7F 01            [12] 1321 	mov	r7,#0x01
      0003DB                       1322 00108$:
                                   1323 ;	usb.c:268: { USB[EPINDEX] = i;
      0003DB 90 FF F1         [24] 1324 	mov	dptr,#0xfff1
      0003DE EF               [12] 1325 	mov	a,r7
      0003DF F0               [24] 1326 	movx	@dptr,a
                                   1327 ;	usb.c:269: USB[EPCON] = 0x00;
      0003E0 90 FF E1         [24] 1328 	mov	dptr,#0xffe1
      0003E3 E4               [12] 1329 	clr	a
      0003E4 F0               [24] 1330 	movx	@dptr,a
                                   1331 ;	usb.c:267: { for ( i=1 ; i<6 ; i++ )
      0003E5 0F               [12] 1332 	inc	r7
      0003E6 BF 06 00         [24] 1333 	cjne	r7,#0x06,00133$
      0003E9                       1334 00133$:
      0003E9 40 F0            [24] 1335 	jc	00108$
      0003EB                       1336 00105$:
                                   1337 ;	usb.c:272: USB[EPINDEX] = EP0;
      0003EB 90 FF F1         [24] 1338 	mov	dptr,#0xfff1
      0003EE E4               [12] 1339 	clr	a
      0003EF F0               [24] 1340 	movx	@dptr,a
                                   1341 ;	usb.c:273: }
      0003F0 22               [24] 1342 	ret
                                   1343 ;------------------------------------------------------------
                                   1344 ;Allocation info for local variables in function 'USB_Set_Interface'
                                   1345 ;------------------------------------------------------------
                                   1346 ;	usb.c:276: void USB_Set_Interface( void )
                                   1347 ;	-----------------------------------------
                                   1348 ;	 function USB_Set_Interface
                                   1349 ;	-----------------------------------------
      0003F1                       1350 _USB_Set_Interface:
                                   1351 ;	usb.c:277: { switch( Ep0.RxTx[4] )
      0003F1 E4               [12] 1352 	clr	a
      0003F2 B5*0A 12         [24] 1353 	cjne	a,(_Ep0 + 0x0007),00105$
                                   1354 ;	usb.c:278: { case 0:  if ( Ep0.RxTx[2] > 0 )          // For Interface1 ( HID )
      0003F5 E5*08            [12] 1355 	mov	a,(_Ep0 + 0x0005)
      0003F7 60 08            [24] 1356 	jz	00103$
                                   1357 ;	usb.c:279: USB[EPCON] |= ( RXSTL | TXSTL );
      0003F9 90 FF E1         [24] 1358 	mov	dptr,#0xffe1
      0003FC E0               [24] 1359 	movx	a,@dptr
      0003FD 44 C0            [12] 1360 	orl	a,#0xc0
      0003FF F0               [24] 1361 	movx	@dptr,a
      000400 22               [24] 1362 	ret
      000401                       1363 00103$:
                                   1364 ;	usb.c:281: USB[TXCNT] = 0;
      000401 90 FF F6         [24] 1365 	mov	dptr,#0xfff6
      000404 E4               [12] 1366 	clr	a
      000405 F0               [24] 1367 	movx	@dptr,a
                                   1368 ;	usb.c:282: break;
                                   1369 ;	usb.c:283: default: USB[EPCON] |= ( RXSTL | TXSTL );
      000406 22               [24] 1370 	ret
      000407                       1371 00105$:
      000407 90 FF E1         [24] 1372 	mov	dptr,#0xffe1
      00040A E0               [24] 1373 	movx	a,@dptr
      00040B 44 C0            [12] 1374 	orl	a,#0xc0
      00040D F0               [24] 1375 	movx	@dptr,a
                                   1376 ;	usb.c:285: }
                                   1377 ;	usb.c:286: }
      00040E 22               [24] 1378 	ret
                                   1379 ;------------------------------------------------------------
                                   1380 ;Allocation info for local variables in function 'USB_Get_Interface'
                                   1381 ;------------------------------------------------------------
                                   1382 ;	usb.c:289: void USB_Get_Interface( void )
                                   1383 ;	-----------------------------------------
                                   1384 ;	 function USB_Get_Interface
                                   1385 ;	-----------------------------------------
      00040F                       1386 _USB_Get_Interface:
                                   1387 ;	usb.c:290: { Ep0.All = 1;
      00040F 75*13 01         [24] 1388 	mov	((_Ep0 + 0x0010) + 0),#0x01
                                   1389 ;	usb.c:291: switch( Ep0.RxTx[4] )
      000412 E4               [12] 1390 	clr	a
      000413 F5*14            [12] 1391 	mov	((_Ep0 + 0x0010) + 1),a
      000415 B5*0A 04         [24] 1392 	cjne	a,(_Ep0 + 0x0007),00102$
                                   1393 ;	usb.c:292: { case 0:  Ep0.RxTx[0] = 0;                // For Interface1 ( HID )
      000418 75*06 00         [24] 1394 	mov	(_Ep0 + 0x0003),#0x00
                                   1395 ;	usb.c:293: break;
                                   1396 ;	usb.c:294: default: USB[EPCON] |= ( RXSTL | TXSTL );
      00041B 22               [24] 1397 	ret
      00041C                       1398 00102$:
      00041C 90 FF E1         [24] 1399 	mov	dptr,#0xffe1
      00041F E0               [24] 1400 	movx	a,@dptr
      000420 44 C0            [12] 1401 	orl	a,#0xc0
      000422 F0               [24] 1402 	movx	@dptr,a
                                   1403 ;	usb.c:296: }
                                   1404 ;	usb.c:297: }
      000423 22               [24] 1405 	ret
                                   1406 ;------------------------------------------------------------
                                   1407 ;Allocation info for local variables in function 'USB_CtrlRd'
                                   1408 ;------------------------------------------------------------
                                   1409 ;BLen                      Allocated to registers r5 
                                   1410 ;------------------------------------------------------------
                                   1411 ;	usb.c:300: void USB_CtrlRd( void )                          // Host In , USB Out ( Only for EP0 )
                                   1412 ;	-----------------------------------------
                                   1413 ;	 function USB_CtrlRd
                                   1414 ;	-----------------------------------------
      000424                       1415 _USB_CtrlRd:
                                   1416 ;	usb.c:304: if ( Ep0.Stage == DATASTAGE )                // In DATASTAGE we should move Data to TXFIFO
      000424 74 5A            [12] 1417 	mov	a,#0x5a
      000426 B5*05 4E         [24] 1418 	cjne	a,(_Ep0 + 0x0002),00109$
                                   1419 ;	usb.c:305: { if ( Ep0.All > Ep0.Unit )
      000429 AE*13            [24] 1420 	mov	r6,((_Ep0 + 0x0010) + 0)
      00042B AF*14            [24] 1421 	mov	r7,((_Ep0 + 0x0010) + 1)
      00042D AD*12            [24] 1422 	mov	r5,(_Ep0 + 0x000f)
      00042F 8D 03            [24] 1423 	mov	ar3,r5
      000431 7C 00            [12] 1424 	mov	r4,#0x00
      000433 C3               [12] 1425 	clr	c
      000434 EB               [12] 1426 	mov	a,r3
      000435 9E               [12] 1427 	subb	a,r6
      000436 EC               [12] 1428 	mov	a,r4
      000437 9F               [12] 1429 	subb	a,r7
      000438 50 02            [24] 1430 	jnc	00102$
                                   1431 ;	usb.c:306: BLen = Ep0.Unit;
      00043A 80 02            [24] 1432 	sjmp	00103$
      00043C                       1433 00102$:
                                   1434 ;	usb.c:308: BLen = Ep0.All;
      00043C 8E 05            [24] 1435 	mov	ar5,r6
      00043E                       1436 00103$:
                                   1437 ;	usb.c:309: USB_Wr_FIFO( Ep0.Buf , BLen );
      00043E 8D*00            [24] 1438 	mov	_USB_Wr_FIFO_PARM_2,r5
      000440 85*0E 82         [24] 1439 	mov	dpl,(_Ep0 + 0x000b)
      000443 85*0F 83         [24] 1440 	mov	dph,((_Ep0 + 0x000b) + 1)
      000446 85*10 F0         [24] 1441 	mov	b,((_Ep0 + 0x000b) + 2)
      000449 C0 05            [24] 1442 	push	ar5
      00044B 12r00r67         [24] 1443 	lcall	_USB_Wr_FIFO
      00044E D0 05            [24] 1444 	pop	ar5
                                   1445 ;	usb.c:310: USB[TXCNT] = BLen;                       // Set this byte will Trigger USB to Transmit Data to the Host
      000450 90 FF F6         [24] 1446 	mov	dptr,#0xfff6
      000453 ED               [12] 1447 	mov	a,r5
      000454 F0               [24] 1448 	movx	@dptr,a
                                   1449 ;	usb.c:311: Ep0.All -= BLen;                         // Calculated the Remain Data size
      000455 8D 06            [24] 1450 	mov	ar6,r5
      000457 7F 00            [12] 1451 	mov	r7,#0x00
      000459 E5*13            [12] 1452 	mov	a,(_Ep0 + 0x0010)
      00045B C3               [12] 1453 	clr	c
      00045C 9E               [12] 1454 	subb	a,r6
      00045D FE               [12] 1455 	mov	r6,a
      00045E E5*14            [12] 1456 	mov	a,((_Ep0 + 0x0010) + 1)
      000460 9F               [12] 1457 	subb	a,r7
      000461 FF               [12] 1458 	mov	r7,a
      000462 8E*13            [24] 1459 	mov	((_Ep0 + 0x0010) + 0),r6
      000464 8F*14            [24] 1460 	mov	((_Ep0 + 0x0010) + 1),r7
                                   1461 ;	usb.c:312: Ep0.Buf += BLen;                         // Move Buffer Address in Right position
      000466 ED               [12] 1462 	mov	a,r5
      000467 25*0E            [12] 1463 	add	a,(_Ep0 + 0x000b)
      000469 FD               [12] 1464 	mov	r5,a
      00046A E4               [12] 1465 	clr	a
      00046B 35*0F            [12] 1466 	addc	a,((_Ep0 + 0x000b) + 1)
      00046D FF               [12] 1467 	mov	r7,a
      00046E AE*10            [24] 1468 	mov	r6,((_Ep0 + 0x000b) + 2)
      000470 8D*0E            [24] 1469 	mov	((_Ep0 + 0x000b) + 0),r5
      000472 8F*0F            [24] 1470 	mov	((_Ep0 + 0x000b) + 1),r7
      000474 8E*10            [24] 1471 	mov	((_Ep0 + 0x000b) + 2),r6
      000476 22               [24] 1472 	ret
      000477                       1473 00109$:
                                   1474 ;	usb.c:315: { USB[EPCON] |= ( RXSTL | TXSTL );         // In STATUSSTAGE we should STAL Rx/Tx
      000477 90 FF E1         [24] 1475 	mov	dptr,#0xffe1
      00047A E0               [24] 1476 	movx	a,@dptr
      00047B 44 C0            [12] 1477 	orl	a,#0xc0
      00047D F0               [24] 1478 	movx	@dptr,a
                                   1479 ;	usb.c:316: if ( Ep0.Stage == SETADDRESS )           // Different from other STATUSSTAGE(importent)
      00047E 74 55            [12] 1480 	mov	a,#0x55
      000480 B5*05 07         [24] 1481 	cjne	a,(_Ep0 + 0x0002),00105$
                                   1482 ;	usb.c:317: USB[UADDR] = Ep0.Tmp;                  // Set Address
      000483 AF*15            [24] 1483 	mov	r7,(_Ep0 + 0x0012)
      000485 90 FF D8         [24] 1484 	mov	dptr,#0xffd8
      000488 EF               [12] 1485 	mov	a,r7
      000489 F0               [24] 1486 	movx	@dptr,a
      00048A                       1487 00105$:
                                   1488 ;	usb.c:318: if ( Ep0.Stage == DFU_RESET )
      00048A 74 44            [12] 1489 	mov	a,#0x44
      00048C B5*05 06         [24] 1490 	cjne	a,(_Ep0 + 0x0002),00111$
                                   1491 ;	usb.c:319: { Reboot_Mcu( REBOOT_TO_ISP );
      00048F 75 82 68         [24] 1492 	mov	dpl,#0x68
                                   1493 ;	usb.c:322: }
      000492 02r00r00         [24] 1494 	ljmp	_Reboot_Mcu
      000495                       1495 00111$:
      000495 22               [24] 1496 	ret
                                   1497 ;------------------------------------------------------------
                                   1498 ;Allocation info for local variables in function 'USB_Stardard_Request'
                                   1499 ;------------------------------------------------------------
                                   1500 ;	usb.c:325: void USB_Stardard_Request( void )
                                   1501 ;	-----------------------------------------
                                   1502 ;	 function USB_Stardard_Request
                                   1503 ;	-----------------------------------------
      000496                       1504 _USB_Stardard_Request:
                                   1505 ;	usb.c:326: { switch( Ep0.RxTx[1] )                        // Request Code
      000496 E5*07            [12] 1506 	mov	a,(_Ep0 + 0x0004)
      000498 FF               [12] 1507 	mov	r7,a
      000499 24 F3            [12] 1508 	add	a,#0xff - 0x0c
      00049B 50 03            [24] 1509 	jnc	00119$
      00049D 02r05r37         [24] 1510 	ljmp	00111$
      0004A0                       1511 00119$:
      0004A0 EF               [12] 1512 	mov	a,r7
      0004A1 24 0A            [12] 1513 	add	a,#(00120$-3-.)
      0004A3 83               [24] 1514 	movc	a,@a+pc
      0004A4 F5 82            [12] 1515 	mov	dpl,a
      0004A6 EF               [12] 1516 	mov	a,r7
      0004A7 24 11            [12] 1517 	add	a,#(00121$-3-.)
      0004A9 83               [24] 1518 	movc	a,@a+pc
      0004AA F5 83            [12] 1519 	mov	dph,a
      0004AC E4               [12] 1520 	clr	a
      0004AD 73               [24] 1521 	jmp	@a+dptr
      0004AE                       1522 00120$:
      0004AErC8                    1523 	.db	00101$
      0004AFrD1                    1524 	.db	00102$
      0004B0r37                    1525 	.db	00111$
      0004B1rDD                    1526 	.db	00103$
      0004B2r37                    1527 	.db	00111$
      0004B3rE9                    1528 	.db	00104$
      0004B4rF6                    1529 	.db	00105$
      0004B5r37                    1530 	.db	00111$
      0004B6rFF                    1531 	.db	00106$
      0004B7r0F                    1532 	.db	00107$
      0004B8r21                    1533 	.db	00109$
      0004B9r1B                    1534 	.db	00108$
      0004BAr2A                    1535 	.db	00110$
      0004BB                       1536 00121$:
      0004BBs04                    1537 	.db	00101$>>8
      0004BCs04                    1538 	.db	00102$>>8
      0004BDs05                    1539 	.db	00111$>>8
      0004BEs04                    1540 	.db	00103$>>8
      0004BFs05                    1541 	.db	00111$>>8
      0004C0s04                    1542 	.db	00104$>>8
      0004C1s04                    1543 	.db	00105$>>8
      0004C2s05                    1544 	.db	00111$>>8
      0004C3s04                    1545 	.db	00106$>>8
      0004C4s05                    1546 	.db	00107$>>8
      0004C5s05                    1547 	.db	00109$>>8
      0004C6s05                    1548 	.db	00108$>>8
      0004C7s05                    1549 	.db	00110$>>8
                                   1550 ;	usb.c:327: { case GET_STATUS:        Ep0.Stage = DATASTAGE;
      0004C8                       1551 00101$:
      0004C8 75*05 5A         [24] 1552 	mov	(_Ep0 + 0x0002),#0x5a
                                   1553 ;	usb.c:328: USB_Get_Status();
      0004CB 12r01r4B         [24] 1554 	lcall	_USB_Get_Status
                                   1555 ;	usb.c:329: USB_CtrlRd();
                                   1556 ;	usb.c:330: break;
      0004CE 02r04r24         [24] 1557 	ljmp	_USB_CtrlRd
                                   1558 ;	usb.c:331: case CLEAR_FRATURE:	Ep0.Stage = STATUSSTAGE;  
      0004D1                       1559 00102$:
      0004D1 75*05 A5         [24] 1560 	mov	(_Ep0 + 0x0002),#0xa5
                                   1561 ;	usb.c:332: USB_Clear_Feature();
      0004D4 12r01rA8         [24] 1562 	lcall	_USB_Clear_Feature
                                   1563 ;	usb.c:333: USB[TXCNT] = 0;  // USB will return ACK immediately when receive IN transaction
      0004D7 90 FF F6         [24] 1564 	mov	dptr,#0xfff6
      0004DA E4               [12] 1565 	clr	a
      0004DB F0               [24] 1566 	movx	@dptr,a
                                   1567 ;	usb.c:334: break;
      0004DC 22               [24] 1568 	ret
                                   1569 ;	usb.c:335: case SET_FEATURE:       Ep0.Stage = STATUSSTAGE;
      0004DD                       1570 00103$:
      0004DD 75*05 A5         [24] 1571 	mov	(_Ep0 + 0x0002),#0xa5
                                   1572 ;	usb.c:336: USB_Set_Feature();
      0004E0 12r02r0A         [24] 1573 	lcall	_USB_Set_Feature
                                   1574 ;	usb.c:337: USB[TXCNT] = 0;  // USB will return ACK immediately when receive IN transaction  
      0004E3 90 FF F6         [24] 1575 	mov	dptr,#0xfff6
      0004E6 E4               [12] 1576 	clr	a
      0004E7 F0               [24] 1577 	movx	@dptr,a
                                   1578 ;	usb.c:338: break;
                                   1579 ;	usb.c:339: case SET_ADDRESS:       Ep0.Stage = SETADDRESS;// Different from other STATUSSTAGE
      0004E8 22               [24] 1580 	ret
      0004E9                       1581 00104$:
      0004E9 75*05 55         [24] 1582 	mov	(_Ep0 + 0x0002),#0x55
                                   1583 ;	usb.c:340: Ep0.Tmp = Ep0.RxTx[2];
      0004EC AF*08            [24] 1584 	mov	r7,(_Ep0 + 0x0005)
      0004EE 8F*15            [24] 1585 	mov	(_Ep0 + 0x0012),r7
                                   1586 ;	usb.c:341: USB[TXCNT] = 0;  // USB will return ACK immediately when receive IN transaction  
      0004F0 90 FF F6         [24] 1587 	mov	dptr,#0xfff6
      0004F3 E4               [12] 1588 	clr	a
      0004F4 F0               [24] 1589 	movx	@dptr,a
                                   1590 ;	usb.c:342: break;
                                   1591 ;	usb.c:343: case GET_DESCRIPTOR:    Ep0.Stage = DATASTAGE;
      0004F5 22               [24] 1592 	ret
      0004F6                       1593 00105$:
      0004F6 75*05 5A         [24] 1594 	mov	(_Ep0 + 0x0002),#0x5a
                                   1595 ;	usb.c:344: USB_Get_Descriptor();
      0004F9 12r02r62         [24] 1596 	lcall	_USB_Get_Descriptor
                                   1597 ;	usb.c:345: USB_CtrlRd();
                                   1598 ;	usb.c:346: break;
                                   1599 ;	usb.c:348: case GET_CONFIGURATION: Ep0.Stage = DATASTAGE;
      0004FC 02r04r24         [24] 1600 	ljmp	_USB_CtrlRd
      0004FF                       1601 00106$:
      0004FF 75*05 5A         [24] 1602 	mov	(_Ep0 + 0x0002),#0x5a
                                   1603 ;	usb.c:349: Ep0.RxTx[0] = Ep0.Tmp;// This value get from SET_CONFIGURATION transaction
      000502 AF*15            [24] 1604 	mov	r7,(_Ep0 + 0x0012)
      000504 8F*06            [24] 1605 	mov	(_Ep0 + 0x0003),r7
                                   1606 ;	usb.c:350: Ep0.All = 1;     // Only 1 byte transfer to the host
      000506 75*13 01         [24] 1607 	mov	((_Ep0 + 0x0010) + 0),#0x01
      000509 75*14 00         [24] 1608 	mov	((_Ep0 + 0x0010) + 1),#0x00
                                   1609 ;	usb.c:351: USB_CtrlRd();
                                   1610 ;	usb.c:352: break;
                                   1611 ;	usb.c:353: case SET_CONFIGURATION: Ep0.Stage = STATUSSTAGE;
      00050C 02r04r24         [24] 1612 	ljmp	_USB_CtrlRd
      00050F                       1613 00107$:
      00050F 75*05 A5         [24] 1614 	mov	(_Ep0 + 0x0002),#0xa5
                                   1615 ;	usb.c:354: USB_Set_Configuration(); // Will store configuration value to Ep0.Tmp
      000512 12r03rA7         [24] 1616 	lcall	_USB_Set_Configuration
                                   1617 ;	usb.c:355: USB[TXCNT] = 0;  // USB will return ACK immediately when receive IN transaction
      000515 90 FF F6         [24] 1618 	mov	dptr,#0xfff6
      000518 E4               [12] 1619 	clr	a
      000519 F0               [24] 1620 	movx	@dptr,a
                                   1621 ;	usb.c:356: break;
                                   1622 ;	usb.c:357: case SET_INTERFACE:     Ep0.Stage = STATUSSTAGE;
      00051A 22               [24] 1623 	ret
      00051B                       1624 00108$:
      00051B 75*05 A5         [24] 1625 	mov	(_Ep0 + 0x0002),#0xa5
                                   1626 ;	usb.c:358: USB_Set_Interface();
                                   1627 ;	usb.c:359: break;
                                   1628 ;	usb.c:360: case GET_INTERFACE:     Ep0.Stage = DATASTAGE;
      00051E 02r03rF1         [24] 1629 	ljmp	_USB_Set_Interface
      000521                       1630 00109$:
      000521 75*05 5A         [24] 1631 	mov	(_Ep0 + 0x0002),#0x5a
                                   1632 ;	usb.c:361: USB_Get_Interface();
      000524 12r04r0F         [24] 1633 	lcall	_USB_Get_Interface
                                   1634 ;	usb.c:362: USB_CtrlRd();
                                   1635 ;	usb.c:363: break;
                                   1636 ;	usb.c:364: case SYNCH_FRAME:       Ep0.Stage = STATUSSTAGE;
      000527 02r04r24         [24] 1637 	ljmp	_USB_CtrlRd
      00052A                       1638 00110$:
      00052A 75*05 A5         [24] 1639 	mov	(_Ep0 + 0x0002),#0xa5
                                   1640 ;	usb.c:365: USB[TXCNT] = 0;  // USB will return ACK immediately when receive IN transaction
      00052D 90 FF F6         [24] 1641 	mov	dptr,#0xfff6
      000530 E4               [12] 1642 	clr	a
      000531 F0               [24] 1643 	movx	@dptr,a
                                   1644 ;	usb.c:366: Ep0.All = 0;
      000532 F5*13            [12] 1645 	mov	((_Ep0 + 0x0010) + 0),a
      000534 F5*14            [12] 1646 	mov	((_Ep0 + 0x0010) + 1),a
                                   1647 ;	usb.c:367: break;
                                   1648 ;	usb.c:368: default:                USB[EPCON] |= ( RXSTL | TXSTL );
      000536 22               [24] 1649 	ret
      000537                       1650 00111$:
      000537 90 FF E1         [24] 1651 	mov	dptr,#0xffe1
      00053A E0               [24] 1652 	movx	a,@dptr
      00053B 44 C0            [12] 1653 	orl	a,#0xc0
      00053D F0               [24] 1654 	movx	@dptr,a
                                   1655 ;	usb.c:370: }
                                   1656 ;	usb.c:371: }
      00053E 22               [24] 1657 	ret
                                   1658 ;------------------------------------------------------------
                                   1659 ;Allocation info for local variables in function 'USB_Class_Request'
                                   1660 ;------------------------------------------------------------
                                   1661 ;	usb.c:374: void USB_Class_Request( void )
                                   1662 ;	-----------------------------------------
                                   1663 ;	 function USB_Class_Request
                                   1664 ;	-----------------------------------------
      00053F                       1665 _USB_Class_Request:
                                   1666 ;	usb.c:375: { switch( Ep0.RxTx[1] )                        // Request Code
      00053F AF*07            [24] 1667 	mov	r7,(_Ep0 + 0x0004)
      000541 BF 01 02         [24] 1668 	cjne	r7,#0x01,00135$
      000544 80 37            [24] 1669 	sjmp	00103$
      000546                       1670 00135$:
      000546 BF 02 02         [24] 1671 	cjne	r7,#0x02,00136$
      000549 80 14            [24] 1672 	sjmp	00101$
      00054B                       1673 00136$:
      00054B BF 03 02         [24] 1674 	cjne	r7,#0x03,00137$
      00054E 80 1E            [24] 1675 	sjmp	00102$
      000550                       1676 00137$:
      000550 BF 09 02         [24] 1677 	cjne	r7,#0x09,00138$
      000553 80 4F            [24] 1678 	sjmp	00106$
      000555                       1679 00138$:
      000555 BF 0A 02         [24] 1680 	cjne	r7,#0x0a,00139$
      000558 80 32            [24] 1681 	sjmp	00104$
      00055A                       1682 00139$:
                                   1683 ;	usb.c:376: { case GET_IDLE:     Ep0.Stage = DATASTAGE;
      00055A BF 0B 69         [24] 1684 	cjne	r7,#0x0b,00107$
      00055D 80 39            [24] 1685 	sjmp	00105$
      00055F                       1686 00101$:
      00055F 75*05 5A         [24] 1687 	mov	(_Ep0 + 0x0002),#0x5a
                                   1688 ;	usb.c:377: Ep0.RxTx[0] = IdleRate;
      000562 85*01*06         [24] 1689 	mov	(_Ep0 + 0x0003),_IdleRate
                                   1690 ;	usb.c:378: Ep0.All = 1;          // Only 1 byte transfer to the host
      000565 75*13 01         [24] 1691 	mov	((_Ep0 + 0x0010) + 0),#0x01
      000568 75*14 00         [24] 1692 	mov	((_Ep0 + 0x0010) + 1),#0x00
                                   1693 ;	usb.c:379: USB_CtrlRd();
                                   1694 ;	usb.c:380: break;
                                   1695 ;	usb.c:381: case GET_PROTOCOL: Ep0.Stage = DATASTAGE;
      00056B 02r04r24         [24] 1696 	ljmp	_USB_CtrlRd
      00056E                       1697 00102$:
      00056E 75*05 5A         [24] 1698 	mov	(_Ep0 + 0x0002),#0x5a
                                   1699 ;	usb.c:382: Ep0.RxTx[0] = Protocol;
      000571 85*02*06         [24] 1700 	mov	(_Ep0 + 0x0003),_Protocol
                                   1701 ;	usb.c:383: Ep0.All = 1;          // Only 1 byte transfer to the host
      000574 75*13 01         [24] 1702 	mov	((_Ep0 + 0x0010) + 0),#0x01
      000577 75*14 00         [24] 1703 	mov	((_Ep0 + 0x0010) + 1),#0x00
                                   1704 ;	usb.c:384: USB_CtrlRd();
                                   1705 ;	usb.c:385: break;
                                   1706 ;	usb.c:386: case GET_REPORT:   Ep0.Stage = DATASTAGE;
      00057A 02r04r24         [24] 1707 	ljmp	_USB_CtrlRd
      00057D                       1708 00103$:
      00057D 75*05 5A         [24] 1709 	mov	(_Ep0 + 0x0002),#0x5a
                                   1710 ;	usb.c:387: Ep0.RxTx[0] = LED_STATUS;
      000580 85*00*06         [24] 1711 	mov	(_Ep0 + 0x0003),_LED_STATUS
                                   1712 ;	usb.c:388: Ep0.All = 1;          // Only 1 byte transfer to the host
      000583 75*13 01         [24] 1713 	mov	((_Ep0 + 0x0010) + 0),#0x01
      000586 75*14 00         [24] 1714 	mov	((_Ep0 + 0x0010) + 1),#0x00
                                   1715 ;	usb.c:389: USB_CtrlRd();
                                   1716 ;	usb.c:390: break;
                                   1717 ;	usb.c:391: case SET_IDLE:     Ep0.Stage = STATUSSTAGE;
      000589 02r04r24         [24] 1718 	ljmp	_USB_CtrlRd
      00058C                       1719 00104$:
      00058C 75*05 A5         [24] 1720 	mov	(_Ep0 + 0x0002),#0xa5
                                   1721 ;	usb.c:392: IdleRate = Ep0.RxTx[3];
      00058F 85*09*01         [24] 1722 	mov	_IdleRate,(_Ep0 + 0x0006)
                                   1723 ;	usb.c:393: USB[TXCNT] = 0;       // USB will return ACK immediately when receive IN transaction
      000592 90 FF F6         [24] 1724 	mov	dptr,#0xfff6
      000595 E4               [12] 1725 	clr	a
      000596 F0               [24] 1726 	movx	@dptr,a
                                   1727 ;	usb.c:394: break;
                                   1728 ;	usb.c:395: case SET_PROTOCOL: Ep0.Stage = STATUSSTAGE;
      000597 22               [24] 1729 	ret
      000598                       1730 00105$:
      000598 75*05 A5         [24] 1731 	mov	(_Ep0 + 0x0002),#0xa5
                                   1732 ;	usb.c:396: Protocol = Ep0.RxTx[2];
      00059B 85*08*02         [24] 1733 	mov	_Protocol,(_Ep0 + 0x0005)
                                   1734 ;	usb.c:397: USB[TXCNT] = 0;       // USB will return ACK immediately when receive IN transaction
      00059E 90 FF F6         [24] 1735 	mov	dptr,#0xfff6
      0005A1 E4               [12] 1736 	clr	a
      0005A2 F0               [24] 1737 	movx	@dptr,a
                                   1738 ;	usb.c:398: break;
                                   1739 ;	usb.c:399: case SET_REPORT:   Ep0.Stage = DFU_STAGE;
      0005A3 22               [24] 1740 	ret
      0005A4                       1741 00106$:
      0005A4 75*05 33         [24] 1742 	mov	(_Ep0 + 0x0002),#0x33
                                   1743 ;	usb.c:400: Ep0.All = Ep0.RxTx[7];
      0005A7 AE*0D            [24] 1744 	mov	r6,(_Ep0 + 0x000a)
      0005A9 7F 00            [12] 1745 	mov	r7,#0x00
      0005AB 8E*13            [24] 1746 	mov	((_Ep0 + 0x0010) + 0),r6
      0005AD 8F*14            [24] 1747 	mov	((_Ep0 + 0x0010) + 1),r7
                                   1748 ;	usb.c:401: Ep0.All <<= 8;
      0005AF 8E 07            [24] 1749 	mov	ar7,r6
      0005B1 7E 00            [12] 1750 	mov	r6,#0x00
      0005B3 8E*13            [24] 1751 	mov	((_Ep0 + 0x0010) + 0),r6
      0005B5 8F*14            [24] 1752 	mov	((_Ep0 + 0x0010) + 1),r7
                                   1753 ;	usb.c:402: Ep0.All += Ep0.RxTx[6];
      0005B7 AC*0C            [24] 1754 	mov	r4,(_Ep0 + 0x0009)
      0005B9 7D 00            [12] 1755 	mov	r5,#0x00
      0005BB EC               [12] 1756 	mov	a,r4
      0005BC 2E               [12] 1757 	add	a,r6
      0005BD FE               [12] 1758 	mov	r6,a
      0005BE ED               [12] 1759 	mov	a,r5
      0005BF 3F               [12] 1760 	addc	a,r7
      0005C0 FF               [12] 1761 	mov	r7,a
      0005C1 8E*13            [24] 1762 	mov	((_Ep0 + 0x0010) + 0),r6
      0005C3 8F*14            [24] 1763 	mov	((_Ep0 + 0x0010) + 1),r7
                                   1764 ;	usb.c:403: break;
                                   1765 ;	usb.c:404: default:           USB[EPCON] |= ( RXSTL | TXSTL );
      0005C5 22               [24] 1766 	ret
      0005C6                       1767 00107$:
      0005C6 90 FF E1         [24] 1768 	mov	dptr,#0xffe1
      0005C9 E0               [24] 1769 	movx	a,@dptr
      0005CA 44 C0            [12] 1770 	orl	a,#0xc0
      0005CC F0               [24] 1771 	movx	@dptr,a
                                   1772 ;	usb.c:406: }
                                   1773 ;	usb.c:407: }
      0005CD 22               [24] 1774 	ret
                                   1775 ;------------------------------------------------------------
                                   1776 ;Allocation info for local variables in function 'USB_CtrlWr'
                                   1777 ;------------------------------------------------------------
                                   1778 ;	usb.c:410: void USB_CtrlWr( void )                          // Host Out , USB In ( Only for EPO )
                                   1779 ;	-----------------------------------------
                                   1780 ;	 function USB_CtrlWr
                                   1781 ;	-----------------------------------------
      0005CE                       1782 _USB_CtrlWr:
                                   1783 ;	usb.c:411: { Ep0.Buf = Ep0.RxTx;                          // Move Buffer address to RxTx[8] array , Use for USB_CtrlRd();
      0005CE 75*0Er06         [24] 1784 	mov	((_Ep0 + 0x000b) + 0),#(_Ep0 + 0x0003)
      0005D1 75*0Fs00         [24] 1785 	mov	((_Ep0 + 0x000b) + 1),#((_Ep0 + 0x0003) >> 8)
      0005D4 75*10 40         [24] 1786 	mov	((_Ep0 + 0x000b) + 2),#0x40
                                   1787 ;	usb.c:412: USB_Ep0_FIFO();                              // Move Rx Data to RxTxBuf buffer
      0005D7 12r00r8F         [24] 1788 	lcall	_USB_Ep0_FIFO
                                   1789 ;	usb.c:413: if ( Ep0.Stage == SETUPSTAGE )               // if Setup Transection will set Ep0.All = 8
      0005DA 74 F0            [12] 1790 	mov	a,#0xf0
      0005DC B5*05 2A         [24] 1791 	cjne	a,(_Ep0 + 0x0002),00107$
                                   1792 ;	usb.c:414: {	Ep0.All = 0;
      0005DF E4               [12] 1793 	clr	a
      0005E0 F5*13            [12] 1794 	mov	((_Ep0 + 0x0010) + 0),a
      0005E2 F5*14            [12] 1795 	mov	((_Ep0 + 0x0010) + 1),a
                                   1796 ;	usb.c:415: switch( Ep0.RxTx[0] & 0x60 )             // Request Type
      0005E4 AE*06            [24] 1797 	mov	r6,(_Ep0 + 0x0003)
      0005E6 53 06 60         [24] 1798 	anl	ar6,#0x60
      0005E9 7F 00            [12] 1799 	mov	r7,#0x00
      0005EB BE 00 05         [24] 1800 	cjne	r6,#0x00,00123$
      0005EE BF 00 02         [24] 1801 	cjne	r7,#0x00,00123$
      0005F1 80 08            [24] 1802 	sjmp	00101$
      0005F3                       1803 00123$:
                                   1804 ;	usb.c:416: { case STANDARD_REQUEST: USB_Stardard_Request();
      0005F3 BE 20 0B         [24] 1805 	cjne	r6,#0x20,00103$
      0005F6 BF 00 08         [24] 1806 	cjne	r7,#0x00,00103$
      0005F9 80 03            [24] 1807 	sjmp	00102$
      0005FB                       1808 00101$:
                                   1809 ;	usb.c:417: break;
                                   1810 ;	usb.c:418: case CLASS_REQUEST:    USB_Class_Request();
      0005FB 02r04r96         [24] 1811 	ljmp	_USB_Stardard_Request
      0005FE                       1812 00102$:
                                   1813 ;	usb.c:419: break;
                                   1814 ;	usb.c:420: default:               USB[EPCON] |= ( RXSTL | TXSTL );
      0005FE 02r05r3F         [24] 1815 	ljmp	_USB_Class_Request
      000601                       1816 00103$:
      000601 90 FF E1         [24] 1817 	mov	dptr,#0xffe1
      000604 E0               [24] 1818 	movx	a,@dptr
      000605 44 C0            [12] 1819 	orl	a,#0xc0
      000607 FF               [12] 1820 	mov	r7,a
      000608 F0               [24] 1821 	movx	@dptr,a
                                   1822 ;	usb.c:422: }
      000609                       1823 00107$:
                                   1824 ;	usb.c:424: }
      000609 22               [24] 1825 	ret
                                   1826 ;------------------------------------------------------------
                                   1827 ;Allocation info for local variables in function 'USB_Set_TxStatus'
                                   1828 ;------------------------------------------------------------
                                   1829 ;Flag                      Allocated to registers r7 
                                   1830 ;Status                    Allocated to registers 
                                   1831 ;------------------------------------------------------------
                                   1832 ;	usb.c:427: void USB_Set_TxStatus( BYTE Flag )
                                   1833 ;	-----------------------------------------
                                   1834 ;	 function USB_Set_TxStatus
                                   1835 ;	-----------------------------------------
      00060A                       1836 _USB_Set_TxStatus:
      00060A AF 82            [24] 1837 	mov	r7,dpl
                                   1838 ;	usb.c:431: Status = USB[TXCON];
      00060C 90 FF F4         [24] 1839 	mov	dptr,#0xfff4
      00060F E0               [24] 1840 	movx	a,@dptr
      000610 FE               [12] 1841 	mov	r6,a
                                   1842 ;	usb.c:432: Status &= 0x0F;                              // Reserve Low nibble
      000611 74 0F            [12] 1843 	mov	a,#0x0f
      000613 5E               [12] 1844 	anl	a,r6
                                   1845 ;	usb.c:433: Status |= Flag;
      000614 42 07            [12] 1846 	orl	ar7,a
                                   1847 ;	usb.c:434: USB[TXCON] = Status;                         // Clear Tx FIFO
      000616 90 FF F4         [24] 1848 	mov	dptr,#0xfff4
      000619 EF               [12] 1849 	mov	a,r7
      00061A F0               [24] 1850 	movx	@dptr,a
                                   1851 ;	usb.c:435: }
      00061B 22               [24] 1852 	ret
                                   1853 ;------------------------------------------------------------
                                   1854 ;Allocation info for local variables in function 'USB_Int'
                                   1855 ;------------------------------------------------------------
                                   1856 ;Status                    Allocated to registers 
                                   1857 ;------------------------------------------------------------
                                   1858 ;	usb.c:439: void USB_Int( void )
                                   1859 ;	-----------------------------------------
                                   1860 ;	 function USB_Int
                                   1861 ;	-----------------------------------------
      00061C                       1862 _USB_Int:
                                   1863 ;	usb.c:443: Status = USB[UPCON];                         // Status in Power Control Register
      00061C 90 FF C9         [24] 1864 	mov	dptr,#0xffc9
      00061F E0               [24] 1865 	movx	a,@dptr
                                   1866 ;	usb.c:445: if ( Status & 0x0F )                         // Into Power Control mode
      000620 FF               [12] 1867 	mov	r7,a
      000621 54 0F            [12] 1868 	anl	a,#0x0f
      000623 70 03            [24] 1869 	jnz	00200$
      000625 02r06rA2         [24] 1870 	ljmp	00131$
      000628                       1871 00200$:
                                   1872 ;	usb.c:446: { if ( Status & USUS )                     // Suspend mode
      000628 EF               [12] 1873 	mov	a,r7
      000629 30 E0 55         [24] 1874 	jnb	acc.0,00118$
                                   1875 ;	usb.c:447: { Status &= 0xF0;
      00062C 74 F0            [12] 1876 	mov	a,#0xf0
      00062E 5F               [12] 1877 	anl	a,r7
                                   1878 ;	usb.c:448: USB[UPCON] = ( Status | USUS );      // Write "1" to Clear this Flag
      00062F 44 01            [12] 1879 	orl	a,#0x01
                                   1880 ;	usb.c:450: Status = USB[UPCON];                 // Status in Power Control Register
      000631 90 FF C9         [24] 1881 	mov	dptr,#0xffc9
      000634 F0               [24] 1882 	movx	@dptr,a
                                   1883 ;	usb.c:451: if (( Status & 0x0F ) == 0x00 )      // Into Power Control mode
      000635 54 0F            [12] 1884 	anl	a,#0x0f
      000637 60 01            [24] 1885 	jz	00203$
      000639 22               [24] 1886 	ret
      00063A                       1887 00203$:
                                   1888 ;	usb.c:452: { KB_LED_Off();                    // Set all LED Off
      00063A 12r00r00         [24] 1889 	lcall	_KB_LED_Off
                                   1890 ;	usb.c:454: if ( Ep0.RWEN == SET )
      00063D 74 01            [12] 1891 	mov	a,#0x01
      00063F B5*03 0C         [24] 1892 	cjne	a,_Ep0,00102$
                                   1893 ;	usb.c:455: { P1 = 0x00;                   // Set scan out line to low
      000642 75 90 00         [24] 1894 	mov	_P1,#0x00
                                   1895 ;	usb.c:456: P2 = 0x00;                   // mean for wakeup function
      000645 75 A0 00         [24] 1896 	mov	_P2,#0x00
                                   1897 ;	usb.c:457: P3 &= 0xE7;                  // P3.3 / P3.4 ( scan out line )
      000648 53 B0 E7         [24] 1898 	anl	_P3,#0xe7
                                   1899 ;	usb.c:459: KBMASK = 0xFF;               // Will Enable KP Interrupt
      00064B 75 D7 FF         [24] 1900 	mov	_KBMASK,#0xff
      00064E                       1901 00102$:
                                   1902 ;	usb.c:462: PCON |= 0x02;                    // Set CPU(8051) into PowerDown mode
      00064E 43 87 02         [24] 1903 	orl	_PCON,#0x02
                                   1904 ;	usb.c:464: Delay_Xms( 1 );
      000651 75 82 01         [24] 1905 	mov	dpl,#0x01
      000654 12r00r00         [24] 1906 	lcall	_Delay_Xms
                                   1907 ;	usb.c:466: if ( Ep0.RWEN == SET )
      000657 74 01            [12] 1908 	mov	a,#0x01
      000659 B5*03 1A         [24] 1909 	cjne	a,_Ep0,00107$
                                   1910 ;	usb.c:467: { if ( KBMASK == 0x00 )        // Clear by KP ISR in " MCU.C "
      00065C E5 D7            [12] 1911 	mov	a,_KBMASK
      00065E 70 0A            [24] 1912 	jnz	00104$
                                   1913 ;	usb.c:468: USB[UPCON] |= URWU;        // Set USB into Wake-up mode
      000660 90 FF C9         [24] 1914 	mov	dptr,#0xffc9
      000663 E0               [24] 1915 	movx	a,@dptr
      000664 44 20            [12] 1916 	orl	a,#0x20
      000666 FE               [12] 1917 	mov	r6,a
      000667 F0               [24] 1918 	movx	@dptr,a
      000668 80 03            [24] 1919 	sjmp	00105$
      00066A                       1920 00104$:
                                   1921 ;	usb.c:470: KBMASK = 0x00;             // Will Disable KP Interrupt
      00066A 75 D7 00         [24] 1922 	mov	_KBMASK,#0x00
      00066D                       1923 00105$:
                                   1924 ;	usb.c:471: P1 = 0xFF;
      00066D 75 90 FF         [24] 1925 	mov	_P1,#0xff
                                   1926 ;	usb.c:472: P2 = 0xFF;
      000670 75 A0 FF         [24] 1927 	mov	_P2,#0xff
                                   1928 ;	usb.c:473: P3 |= 0x18;
      000673 43 B0 18         [24] 1929 	orl	_P3,#0x18
      000676                       1930 00107$:
                                   1931 ;	usb.c:476: if ( Ep0.EmuOk == SET )          // Set USB LED ON after " SET_CONFIGURATION "
      000676 74 01            [12] 1932 	mov	a,#0x01
      000678 B5*04 02         [24] 1933 	cjne	a,(_Ep0 + 0x0001),00209$
      00067B 80 01            [24] 1934 	sjmp	00210$
      00067D                       1935 00209$:
      00067D 22               [24] 1936 	ret
      00067E                       1937 00210$:
                                   1938 ;	usb.c:477: KB_LED_Status();               // Restore LED status
      00067E 02r00r00         [24] 1939 	ljmp	_KB_LED_Status
      000681                       1940 00118$:
                                   1941 ;	usb.c:481: { if ( Status & URST )                 // Reset mode
      000681 EF               [12] 1942 	mov	a,r7
      000682 30 E2 0F         [24] 1943 	jnb	acc.2,00115$
                                   1944 ;	usb.c:482: {	Status &= 0xF0;
      000685 74 F0            [12] 1945 	mov	a,#0xf0
      000687 5F               [12] 1946 	anl	a,r7
                                   1947 ;	usb.c:483: USB[UPCON] = ( Status | URST );  // Write "1" to Clear this Flag
      000688 44 04            [12] 1948 	orl	a,#0x04
      00068A 90 FF C9         [24] 1949 	mov	dptr,#0xffc9
      00068D F0               [24] 1950 	movx	@dptr,a
                                   1951 ;	usb.c:484: initKeyboard();
      00068E 12r00r00         [24] 1952 	lcall	_initKeyboard
                                   1953 ;	usb.c:485: Initial_USB();
      000691 02r00r00         [24] 1954 	ljmp	_Initial_USB
      000694                       1955 00115$:
                                   1956 ;	usb.c:487: else if ( Status & URSM )            // Resume mode  
      000694 EF               [12] 1957 	mov	a,r7
      000695 30 E1 51         [24] 1958 	jnb	acc.1,00133$
                                   1959 ;	usb.c:488: { Status &= 0xF0;
      000698 74 F0            [12] 1960 	mov	a,#0xf0
      00069A 5F               [12] 1961 	anl	a,r7
                                   1962 ;	usb.c:489: USB[UPCON] = ( Status | URSM );  // Write "1" to Clear this Flag
      00069B 44 02            [12] 1963 	orl	a,#0x02
      00069D 90 FF C9         [24] 1964 	mov	dptr,#0xffc9
      0006A0 F0               [24] 1965 	movx	@dptr,a
      0006A1 22               [24] 1966 	ret
      0006A2                       1967 00131$:
                                   1968 ;	usb.c:494: { Status = USB[UIFLG];
      0006A2 90 FF DB         [24] 1969 	mov	dptr,#0xffdb
      0006A5 E0               [24] 1970 	movx	a,@dptr
                                   1971 ;	usb.c:495: if ( Status & UTXD1 )                    // EP1 Transmit
      0006A6 FF               [12] 1972 	mov	r7,a
      0006A7 30 E2 1B         [24] 1973 	jnb	acc.2,00128$
                                   1974 ;	usb.c:496: { USB[UIFLG] = UTXD1;                  // Write "1" to Clear this Flag
      0006AA 90 FF DB         [24] 1975 	mov	dptr,#0xffdb
      0006AD 74 04            [12] 1976 	mov	a,#0x04
      0006AF F0               [24] 1977 	movx	@dptr,a
                                   1978 ;	usb.c:497: USB[EPINDEX] = EP1;
      0006B0 90 FF F1         [24] 1979 	mov	dptr,#0xfff1
      0006B3 74 01            [12] 1980 	mov	a,#0x01
      0006B5 F0               [24] 1981 	movx	@dptr,a
                                   1982 ;	usb.c:498: USB_Set_TxStatus( TXFFRC );
      0006B6 75 82 10         [24] 1983 	mov	dpl,#0x10
      0006B9 12r06r0A         [24] 1984 	lcall	_USB_Set_TxStatus
                                   1985 ;	usb.c:499: if ( TxBusy == SET )
      0006BC 74 01            [12] 1986 	mov	a,#0x01
      0006BE B5*00 28         [24] 1987 	cjne	a,_TxBusy,00133$
                                   1988 ;	usb.c:500: TxBusy = CLR;
      0006C1 75*00 00         [24] 1989 	mov	_TxBusy,#0x00
      0006C4 22               [24] 1990 	ret
      0006C5                       1991 00128$:
                                   1992 ;	usb.c:502: else if ( Status & URXD0 )               // EP0 Receive
      0006C5 EF               [12] 1993 	mov	a,r7
      0006C6 30 E1 0E         [24] 1994 	jnb	acc.1,00125$
                                   1995 ;	usb.c:503: { USB[UIFLG] = URXD0;                  // Write "1" to Clear this Flag
      0006C9 90 FF DB         [24] 1996 	mov	dptr,#0xffdb
      0006CC 74 02            [12] 1997 	mov	a,#0x02
      0006CE F0               [24] 1998 	movx	@dptr,a
                                   1999 ;	usb.c:504: USB[EPINDEX] = EP0;
      0006CF 90 FF F1         [24] 2000 	mov	dptr,#0xfff1
      0006D2 E4               [12] 2001 	clr	a
      0006D3 F0               [24] 2002 	movx	@dptr,a
                                   2003 ;	usb.c:505: USB_CtrlWr();                        // USB Standard Device Request(maybe)
      0006D4 02r05rCE         [24] 2004 	ljmp	_USB_CtrlWr
      0006D7                       2005 00125$:
                                   2006 ;	usb.c:507: else if ( Status & UTXD0 )               // EP0 Transmit
      0006D7 EF               [12] 2007 	mov	a,r7
      0006D8 30 E0 0E         [24] 2008 	jnb	acc.0,00133$
                                   2009 ;	usb.c:508: { USB[UIFLG] = UTXD0;                  // Write "1" to Clear this Flag
      0006DB 90 FF DB         [24] 2010 	mov	dptr,#0xffdb
      0006DE 74 01            [12] 2011 	mov	a,#0x01
      0006E0 F0               [24] 2012 	movx	@dptr,a
                                   2013 ;	usb.c:509: USB[EPINDEX] = EP0;
      0006E1 90 FF F1         [24] 2014 	mov	dptr,#0xfff1
      0006E4 E4               [12] 2015 	clr	a
      0006E5 F0               [24] 2016 	movx	@dptr,a
                                   2017 ;	usb.c:510: USB_CtrlRd();
                                   2018 ;	usb.c:513: }
      0006E6 02r04r24         [24] 2019 	ljmp	_USB_CtrlRd
      0006E9                       2020 00133$:
      0006E9 22               [24] 2021 	ret
                                   2022 	.area CSEG    (CODE)
                                   2023 	.area CONST   (CODE)
      000000                       2024 _KB_HID_REPORT:
      000000 05                    2025 	.db #0x05	; 5
      000001 01                    2026 	.db #0x01	; 1
      000002 09                    2027 	.db #0x09	; 9
      000003 06                    2028 	.db #0x06	; 6
      000004 A1                    2029 	.db #0xa1	; 161
      000005 01                    2030 	.db #0x01	; 1
      000006 05                    2031 	.db #0x05	; 5
      000007 07                    2032 	.db #0x07	; 7
      000008 19                    2033 	.db #0x19	; 25
      000009 E0                    2034 	.db #0xe0	; 224
      00000A 29                    2035 	.db #0x29	; 41
      00000B E7                    2036 	.db #0xe7	; 231
      00000C 15                    2037 	.db #0x15	; 21
      00000D 00                    2038 	.db #0x00	; 0
      00000E 25                    2039 	.db #0x25	; 37
      00000F 01                    2040 	.db #0x01	; 1
      000010 75                    2041 	.db #0x75	; 117	'u'
      000011 01                    2042 	.db #0x01	; 1
      000012 95                    2043 	.db #0x95	; 149
      000013 08                    2044 	.db #0x08	; 8
      000014 81                    2045 	.db #0x81	; 129
      000015 02                    2046 	.db #0x02	; 2
      000016 95                    2047 	.db #0x95	; 149
      000017 01                    2048 	.db #0x01	; 1
      000018 75                    2049 	.db #0x75	; 117	'u'
      000019 08                    2050 	.db #0x08	; 8
      00001A 81                    2051 	.db #0x81	; 129
      00001B 01                    2052 	.db #0x01	; 1
      00001C 95                    2053 	.db #0x95	; 149
      00001D 03                    2054 	.db #0x03	; 3
      00001E 75                    2055 	.db #0x75	; 117	'u'
      00001F 01                    2056 	.db #0x01	; 1
      000020 05                    2057 	.db #0x05	; 5
      000021 08                    2058 	.db #0x08	; 8
      000022 19                    2059 	.db #0x19	; 25
      000023 01                    2060 	.db #0x01	; 1
      000024 29                    2061 	.db #0x29	; 41
      000025 03                    2062 	.db #0x03	; 3
      000026 91                    2063 	.db #0x91	; 145
      000027 02                    2064 	.db #0x02	; 2
      000028 95                    2065 	.db #0x95	; 149
      000029 05                    2066 	.db #0x05	; 5
      00002A 75                    2067 	.db #0x75	; 117	'u'
      00002B 01                    2068 	.db #0x01	; 1
      00002C 91                    2069 	.db #0x91	; 145
      00002D 01                    2070 	.db #0x01	; 1
      00002E 95                    2071 	.db #0x95	; 149
      00002F 06                    2072 	.db #0x06	; 6
      000030 75                    2073 	.db #0x75	; 117	'u'
      000031 08                    2074 	.db #0x08	; 8
      000032 15                    2075 	.db #0x15	; 21
      000033 00                    2076 	.db #0x00	; 0
      000034 26                    2077 	.db #0x26	; 38
      000035 FF                    2078 	.db #0xff	; 255
      000036 00                    2079 	.db #0x00	; 0
      000037 05                    2080 	.db #0x05	; 5
      000038 07                    2081 	.db #0x07	; 7
      000039 19                    2082 	.db #0x19	; 25
      00003A 00                    2083 	.db #0x00	; 0
      00003B 2A                    2084 	.db #0x2a	; 42
      00003C FF                    2085 	.db #0xff	; 255
      00003D 00                    2086 	.db #0x00	; 0
      00003E 81                    2087 	.db #0x81	; 129
      00003F 00                    2088 	.db #0x00	; 0
      000040 09                    2089 	.db #0x09	; 9
      000041 00                    2090 	.db #0x00	; 0
      000042 95                    2091 	.db #0x95	; 149
      000043 08                    2092 	.db #0x08	; 8
      000044 75                    2093 	.db #0x75	; 117	'u'
      000045 08                    2094 	.db #0x08	; 8
      000046 B1                    2095 	.db #0xb1	; 177
      000047 00                    2096 	.db #0x00	; 0
      000048 C0                    2097 	.db #0xc0	; 192
      000049                       2098 _DEVICE_DESCRIPTOR:
      000049 12                    2099 	.db #0x12	; 18
      00004A 01                    2100 	.db #0x01	; 1
      00004B 10                    2101 	.db #0x10	; 16
      00004C 01                    2102 	.db #0x01	; 1
      00004D 00                    2103 	.db #0x00	; 0
      00004E 00                    2104 	.db #0x00	; 0
      00004F 00                    2105 	.db #0x00	; 0
      000050 08                    2106 	.db #0x08	; 8
      000051 6A                    2107 	.db #0x6a	; 106	'j'
      000052 0E                    2108 	.db #0x0e	; 14
      000053 0C                    2109 	.db #0x0c	; 12
      000054 03                    2110 	.db #0x03	; 3
      000055 30                    2111 	.db #0x30	; 48	'0'
      000056 01                    2112 	.db #0x01	; 1
      000057 01                    2113 	.db #0x01	; 1
      000058 02                    2114 	.db #0x02	; 2
      000059 00                    2115 	.db #0x00	; 0
      00005A 01                    2116 	.db #0x01	; 1
      00005B                       2117 _CONGFIGURATION_DESCRIPTOR:
      00005B 09                    2118 	.db #0x09	; 9
      00005C 02                    2119 	.db #0x02	; 2
      00005D 22                    2120 	.db #0x22	; 34
      00005E 00                    2121 	.db #0x00	; 0
      00005F 01                    2122 	.db #0x01	; 1
      000060 01                    2123 	.db #0x01	; 1
      000061 00                    2124 	.db #0x00	; 0
      000062 A0                    2125 	.db #0xa0	; 160
      000063 32                    2126 	.db #0x32	; 50	'2'
      000064                       2127 _KB_INTERFACE_DESCRIPTOR:
      000064 09                    2128 	.db #0x09	; 9
      000065 04                    2129 	.db #0x04	; 4
      000066 00                    2130 	.db #0x00	; 0
      000067 00                    2131 	.db #0x00	; 0
      000068 01                    2132 	.db #0x01	; 1
      000069 03                    2133 	.db #0x03	; 3
      00006A 01                    2134 	.db #0x01	; 1
      00006B 01                    2135 	.db #0x01	; 1
      00006C 00                    2136 	.db #0x00	; 0
      00006D                       2137 _KB_HID_DESCRIPTOR:
      00006D 09                    2138 	.db #0x09	; 9
      00006E 21                    2139 	.db #0x21	; 33
      00006F 10                    2140 	.db #0x10	; 16
      000070 01                    2141 	.db #0x01	; 1
      000071 00                    2142 	.db #0x00	; 0
      000072 01                    2143 	.db #0x01	; 1
      000073 22                    2144 	.db #0x22	; 34
      000074 49                    2145 	.db #0x49	; 73	'I'
      000075 00                    2146 	.db #0x00	; 0
      000076                       2147 _KB_INTERRUPT_IN_ENDPOINT_DESCRIPTOR:
      000076 07                    2148 	.db #0x07	; 7
      000077 05                    2149 	.db #0x05	; 5
      000078 81                    2150 	.db #0x81	; 129
      000079 03                    2151 	.db #0x03	; 3
      00007A 08                    2152 	.db #0x08	; 8
      00007B 00                    2153 	.db #0x00	; 0
      00007C 0A                    2154 	.db #0x0a	; 10
      00007D                       2155 _LANGUAGEID_DESCRIPTOR:
      00007D 04                    2156 	.db #0x04	; 4
      00007E 03                    2157 	.db #0x03	; 3
      00007F 09                    2158 	.db #0x09	; 9
      000080 04                    2159 	.db #0x04	; 4
      000081                       2160 _MANUFACTURER_DESCRIPTOR:
      000081 26                    2161 	.db #0x26	; 38
      000082 03                    2162 	.db #0x03	; 3
      000083 54                    2163 	.db #0x54	; 84	'T'
      000084 00                    2164 	.db #0x00	; 0
      000085 72                    2165 	.db #0x72	; 114	'r'
      000086 00                    2166 	.db #0x00	; 0
      000087 75                    2167 	.db #0x75	; 117	'u'
      000088 00                    2168 	.db #0x00	; 0
      000089 6C                    2169 	.db #0x6c	; 108	'l'
      00008A 00                    2170 	.db #0x00	; 0
      00008B 79                    2171 	.db #0x79	; 121	'y'
      00008C 00                    2172 	.db #0x00	; 0
      00008D 45                    2173 	.db #0x45	; 69	'E'
      00008E 00                    2174 	.db #0x00	; 0
      00008F 72                    2175 	.db #0x72	; 114	'r'
      000090 00                    2176 	.db #0x00	; 0
      000091 67                    2177 	.db #0x67	; 103	'g'
      000092 00                    2178 	.db #0x00	; 0
      000093 6F                    2179 	.db #0x6f	; 111	'o'
      000094 00                    2180 	.db #0x00	; 0
      000095 6E                    2181 	.db #0x6e	; 110	'n'
      000096 00                    2182 	.db #0x00	; 0
      000097 6F                    2183 	.db #0x6f	; 111	'o'
      000098 00                    2184 	.db #0x00	; 0
      000099 6D                    2185 	.db #0x6d	; 109	'm'
      00009A 00                    2186 	.db #0x00	; 0
      00009B 69                    2187 	.db #0x69	; 105	'i'
      00009C 00                    2188 	.db #0x00	; 0
      00009D 63                    2189 	.db #0x63	; 99	'c'
      00009E 00                    2190 	.db #0x00	; 0
      00009F 2E                    2191 	.db #0x2e	; 46
      0000A0 00                    2192 	.db #0x00	; 0
      0000A1 63                    2193 	.db #0x63	; 99	'c'
      0000A2 00                    2194 	.db #0x00	; 0
      0000A3 6F                    2195 	.db #0x6f	; 111	'o'
      0000A4 00                    2196 	.db #0x00	; 0
      0000A5 6D                    2197 	.db #0x6d	; 109	'm'
      0000A6 00                    2198 	.db #0x00	; 0
      0000A7                       2199 _PRODUCT_DESCRIPTOR:
      0000A7 44                    2200 	.db #0x44	; 68	'D'
      0000A8 03                    2201 	.db #0x03	; 3
      0000A9 54                    2202 	.db #0x54	; 84	'T'
      0000AA 00                    2203 	.db #0x00	; 0
      0000AB 72                    2204 	.db #0x72	; 114	'r'
      0000AC 00                    2205 	.db #0x00	; 0
      0000AD 75                    2206 	.db #0x75	; 117	'u'
      0000AE 00                    2207 	.db #0x00	; 0
      0000AF 6C                    2208 	.db #0x6c	; 108	'l'
      0000B0 00                    2209 	.db #0x00	; 0
      0000B1 79                    2210 	.db #0x79	; 121	'y'
      0000B2 00                    2211 	.db #0x00	; 0
      0000B3 20                    2212 	.db #0x20	; 32
      0000B4 00                    2213 	.db #0x00	; 0
      0000B5 45                    2214 	.db #0x45	; 69	'E'
      0000B6 00                    2215 	.db #0x00	; 0
      0000B7 72                    2216 	.db #0x72	; 114	'r'
      0000B8 00                    2217 	.db #0x00	; 0
      0000B9 67                    2218 	.db #0x67	; 103	'g'
      0000BA 00                    2219 	.db #0x00	; 0
      0000BB 6F                    2220 	.db #0x6f	; 111	'o'
      0000BC 00                    2221 	.db #0x00	; 0
      0000BD 6E                    2222 	.db #0x6e	; 110	'n'
      0000BE 00                    2223 	.db #0x00	; 0
      0000BF 6F                    2224 	.db #0x6f	; 111	'o'
      0000C0 00                    2225 	.db #0x00	; 0
      0000C1 6D                    2226 	.db #0x6d	; 109	'm'
      0000C2 00                    2227 	.db #0x00	; 0
      0000C3 69                    2228 	.db #0x69	; 105	'i'
      0000C4 00                    2229 	.db #0x00	; 0
      0000C5 63                    2230 	.db #0x63	; 99	'c'
      0000C6 00                    2231 	.db #0x00	; 0
      0000C7 20                    2232 	.db #0x20	; 32
      0000C8 00                    2233 	.db #0x00	; 0
      0000C9 43                    2234 	.db #0x43	; 67	'C'
      0000CA 00                    2235 	.db #0x00	; 0
      0000CB 6F                    2236 	.db #0x6f	; 111	'o'
      0000CC 00                    2237 	.db #0x00	; 0
      0000CD 6D                    2238 	.db #0x6d	; 109	'm'
      0000CE 00                    2239 	.db #0x00	; 0
      0000CF 70                    2240 	.db #0x70	; 112	'p'
      0000D0 00                    2241 	.db #0x00	; 0
      0000D1 75                    2242 	.db #0x75	; 117	'u'
      0000D2 00                    2243 	.db #0x00	; 0
      0000D3 74                    2244 	.db #0x74	; 116	't'
      0000D4 00                    2245 	.db #0x00	; 0
      0000D5 65                    2246 	.db #0x65	; 101	'e'
      0000D6 00                    2247 	.db #0x00	; 0
      0000D7 72                    2248 	.db #0x72	; 114	'r'
      0000D8 00                    2249 	.db #0x00	; 0
      0000D9 20                    2250 	.db #0x20	; 32
      0000DA 00                    2251 	.db #0x00	; 0
      0000DB 4B                    2252 	.db #0x4b	; 75	'K'
      0000DC 00                    2253 	.db #0x00	; 0
      0000DD 65                    2254 	.db #0x65	; 101	'e'
      0000DE 00                    2255 	.db #0x00	; 0
      0000DF 79                    2256 	.db #0x79	; 121	'y'
      0000E0 00                    2257 	.db #0x00	; 0
      0000E1 62                    2258 	.db #0x62	; 98	'b'
      0000E2 00                    2259 	.db #0x00	; 0
      0000E3 6F                    2260 	.db #0x6f	; 111	'o'
      0000E4 00                    2261 	.db #0x00	; 0
      0000E5 61                    2262 	.db #0x61	; 97	'a'
      0000E6 00                    2263 	.db #0x00	; 0
      0000E7 72                    2264 	.db #0x72	; 114	'r'
      0000E8 00                    2265 	.db #0x00	; 0
      0000E9 64                    2266 	.db #0x64	; 100	'd'
      0000EA 00                    2267 	.db #0x00	; 0
      0000EB                       2268 _SERIALNUMBER_DESCRIPTOR:
      0000EB 0E                    2269 	.db #0x0e	; 14
      0000EC 03                    2270 	.db #0x03	; 3
      0000ED 36                    2271 	.db #0x36	; 54	'6'
      0000EE 00                    2272 	.db #0x00	; 0
      0000EF 32                    2273 	.db #0x32	; 50	'2'
      0000F0 00                    2274 	.db #0x00	; 0
      0000F1 31                    2275 	.db #0x31	; 49	'1'
      0000F2 00                    2276 	.db #0x00	; 0
      0000F3 30                    2277 	.db #0x30	; 48	'0'
      0000F4 00                    2278 	.db #0x00	; 0
      0000F5 33                    2279 	.db #0x33	; 51	'3'
      0000F6 00                    2280 	.db #0x00	; 0
      0000F7 31                    2281 	.db #0x31	; 49	'1'
      0000F8 00                    2282 	.db #0x00	; 0
                                   2283 	.area XINIT   (CODE)
                                   2284 	.area CABS    (ABS,CODE)
